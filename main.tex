\documentclass[12pt]{article}
\usepackage{fontspec}
\usepackage{xcolor}
\usepackage{listings}
\usepackage[justification=centering]{caption}
\usepackage{subcaption}
\usepackage{cite}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{bussproofs}
\usepackage{tikz}
\usepackage{float}
\usepackage{graphicx}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{array}
\usepackage{stmaryrd}
\usepackage{pifont}
\usepackage{enumitem}

\input{defs.tex}

\begin{document}

\begin{center}
{\center \LARGE Compiling Event Structures to the Intermediate Memory Model }
\end{center}

\section{Event Structure Model}

\begin{definition}
  An \emph{event structure} $\lES$ is a tuple
  $\tup{\lE, \lEi, \lTID, \lLAB, \lMOD, \lPO, \lRMW, \lRF, \lEW, \lMO}$ where:
  \begin{itemize}
  \item $\lE \subseteq \N$ --- finite set of events. 
  \item $\lEi \subseteq \lE$ --- initialization events.
  \item $\lTID \defeq \lE \fun \Tid$ --- function that assigns a thread id to every event.
    Given thread id $i \in \Tid$ we will denote by $\lE_i$ the set of all events belonging 
    to $i^{th}$ thread, that is $\lE_i \defeq \{e \in \lE ~|~ \lTID(e) = i\}$.
    We assume that if $e \in \lEi$ then $\lTID(e) = 0$.
  \item $\lLAB \defeq \lE \fun \Lab$ --- function that assigns a label to every event.
    Labels are of one of the following forms:
    \begin{itemize}
    \item $\rlabExExpl{x}{v}{\mathtt{f}}$ --- a read, where $x \in \Loc$, $v \in \Val$ 
      and $\mathtt{f} \in \{\Ex, \NotEx\}$ is an exclusive flag 
      (we will denote exclusive reads as $\rlabEx{x}{v}$,
       for non-exclusive reads we will omit the flag);
    \item $\wlab{x}{v}$ --- a write, where $x \in \Loc$, $v \in \Val$;
    \item $\flab$ --- a fence.
    \end{itemize}
    $\lLAB$ induces the following functions:
    \begin{itemize}
    \item $\lTYP \defeq \lE \fun \{\lR, \lW, \lF\}$ --- assigns a type to every event;
    \item $\lLOC \defeq \lE \pfun \Loc $ --- returns the location of event (when applicable);
    \item $\lVALR \defeq \lE \pfun \Val$ --- returns the read value of event (when applicable);
    \item $\lVALW \defeq \lE \pfun \Val$ --- returns the written value of event (when applicable).
    \end{itemize}
    We assume that $\forall{e} \in \lEi. \; \lLAB(e) = \wlab{x}{0}$.
  \item A function $\lMOD = G.\lE \rightarrow \Mod$ is a memory order assignment.
    Elements of the set $\Mod \defeq \{ \rlx, \rel, \acq, \acqrel, \sco \}$ are
    called \emph{memory order} parameters.
    Additionally, $\lMOD$ satisfies the following constraints:
    \begin{itemize}
    \item $e \in \lR \Rightarrow \lMOD(e) \in \{ \rlx, \acq, \sco \}$;
    \item $e \in \lW \Rightarrow \lMOD(e) \in \{ \rlx, \rel, \sco \}$;
    \item $e \in \lF \Rightarrow \lMOD(e) \in \{ \rlx, \acqrel, \sco \}$.
    \end{itemize}
  \item $\lPO \subseteq \lE \times \lE$ --- \emph{program order}, which is a strict partial order.
    It orders all initialization events before all other events,
    that is $\lEi \times (\lE \setminus \lEi) \subseteq \lPO$.
    Moreover, $\lPO$ induces the \emph{conflict relation} $\lCF$.
    \begin{itemize}
      \item  $\lCF \defeq \lPO^{-1};[E];\lPO \setminus \lPO^{=}$.
    \end{itemize}
  \item $\lRMW \subseteq [\lR];(\lPO_{imm} \cap =_{loc});[\lW]$ ---
    \emph{read-modify-write pairs}.
  \item $\lRF \subseteq \lW; =_{loc}; \lR$ --- \emph{reads-from} relation, which the following
    hold for:
    \begin{itemize}
    \item $\forall{\tup{a, b}} \in \lRF. \; \lVALW(a) = \lVALR(b)$;
    \item $\forall{a_1, a_2, b}. \; \tup{a_1, b} \in \lRF \wedge \tup{a_2, b} \in \lRF \Rightarrow a_1 = a_2.$
    \end{itemize}
  \item $\lEW \subseteq \lW \times \lW$ --- is the \emph{equal write} relation, 
    which is an irreflexive, symmetric and transitive relation between conflicting writes on the
    same location writing same values 
    (that is $\lEW(e_1, e_2) \Rightarrow \lVALW(e_1) = \lVALW(e_2)$).
    Given $\lRF$, $\lEW$ and $\lCF$ we will also define a derived \emph{justified from} relation:
    \begin{itemize}
      \item $\lJF \defeq \lEW^?;\lRF \setminus \lCF$
    \end{itemize}
  \item $\lMO \subseteq \lW \times \lW$ --- \emph{modification order}, which is a strict partial order.
  \end{itemize}
\end{definition}

\begin{definition}
  Using the primitive relations of an event structure $\lES$,
  we define following derived relations:
  \begin{itemize}
    \item $\lES.\lRB \defeq (\lES.\lJF^{-1};\lES.\lMO) \setminus \lES.\lCF^?$ --- 
      \emph{reads before};
    \item $\lES.\lECO \defeq (\lES.\lJF \cup \lES.\lRB \cup \lES.\lMO)^+$ --- 
      \emph{extended coherence order}.
  \end{itemize}
\end{definition}

\begin{definition}
  Giving an event structure $\lES$ we define the \emph{happens-before} relation $\lHB$
  using auxililarly relations: 
  $\lRSEQ$ --- release sequence,
  $\lRELP$ --- release prefix and
  $\lSW$ --- synchronize-with.
  \begin{itemize}
  \item $\lRSEQ \defeq [\lWsqeq{rlx}];(\lmakeLoc{\lPO};[\lWsqeq{rlx}] \cup 
    (\lmakeLoc{\lPO^?};[\lWsqeq{\rlx}];\lJF;\lRMW)^*)$;
  \item $\lRELP \defeq [\lEsqeq{rel}];([\lW] \cup [\lF];\lPO);\lRSEQ$;
  \item $\lSW \defeq \lRELP; (\lRFI \cup \lmakeLoc{\lPO^?};\lRFE); [\lR \cup \lPO;[\lF]);[\lEsqeq{\acq}]$;
  \item $\lHB \defeq (\lPO \cup \lSW)^+$.
  \end{itemize}
\end{definition}

\begin{definition}
  For an event $e$ from an event structure $\lES$
  the \emph{masking set} of $e$, denoted as $\lMASK(\lES, e)$,
  is a set of conflicting write events that $e$ depends on.
  This set is called masking, because its elements might make an event $e$ \emph{invisible}.
  \begin{itemize}
  \item $\lMASK(\lES, e) \defeq
    \{w \in \lES.\lW ~|~ \tup{w, e} \in \lES.\lCF \cap (\lES.\lPO \cup \lES.\lRF)^+ \}$
  \end{itemize}
\end{definition}

\begin{definition}
  For an event structure $\lES$ the set of its visible events $\lVIS(\lES)$ defined as follow:
  \begin{itemize}
    \item $\lVIS(\lES) \defeq 
      \{ e \in \lES ~|~ \lES.\lW;(\lES.\lCF \cap (\lES.\lPO \cup \lES.\lRF)^+);[e] \subseteq 
         \lES.\lEW;\lES.\lPO^=
      \}$,
  \end{itemize}
  or equivalently:
  \begin{itemize}
    \item $\lVIS(\lES) \defeq 
      \{ e \in \lES ~|~ \forall{w \in \lMASK(\lES, e)} ~.~ \tup{w, e} \in \lES.\lEW;\lES.\lPO^=\}$.
  \end{itemize}
\end{definition}

\begin{definition}
  Given an event structure $\lES$ we will a call a tuple $\tup{\lE, \lPO, \lRMW, \lRF, \lMO}$ 
  its \emph{execution} $\lX$ if the following conditions hold:
  \begin{itemize}
    \item $\lX.\lE \subseteq \lVIS(\lES)$;
    \item $[\lX.\lE];\lES.\lCF;[\lX.\lE] = \emptyset$;
    \item $\lES.\lPO;[\lX.\lE] \subseteq \lX.\lE \times \lX.\lE$;
    \item $\forall{\tup{e, e'}} \in (\lX.\lE;\lES.\lPO;[\lES.\lE \setminus \lX.\lE]) ~.~ 
      \exists{e''} \in \lX.\lE ~.~ \tup{e', e''} \in \lES.\lCF$;
    \item $\lX.\lPO = [\lX.\lE];\lES.\lPO;[\lX.\lE]$;
    \item $\lX.\lRMW = [\lX.\lE];\lES.\lRMW;[\lX.\lE]$;
    \item $\lX.\lRF = [\lX.\lE];\lES.\lJF;[\lX.\lE]$;
    \item $\lX.\lMO = [\lX.\lE];\lES.\lMO;[\lX.\lE]$.
  \end{itemize}
\end{definition}

\begin{definition}
  A function $O_{\lX} : \Loc \fun \Val$ is an \emph{outcome} 
  of an event structure's $\lES$ execution $\lX$
  if for every $x \in \Loc$ either $O_{\lX}(x) = \lES.\lVALW(w)$ 
  for some $\lX.\lMO$-maximal write event $w$, 
  or $O_{\lG} = 0$ and $\lX.\lW_x = \emptyset$.
\end{definition}

\section{Intermediate Memory Model}

\begin{definition}
  An \imm execution graph $\lG$ is a tuple \\
  $\tup{\lE, \lLAB, \lMOD, \lRMW, \lRF, \lMO, \lDATA, \lADDR, \lCTRL, \lCASDEP}$ where:
  \begin{itemize}
    \item $\lE$ is a set of events. 
      Events in \imm have different representation comparing to the event structure model. 
      That is, an event is either:
      \begin{itemize}
        \item an \emph{initialization} event $\tup{\lINIT~x}$ where $x \in \Loc$;
        \item a \emph{non-initialization} event $\tup{i, n}$ where $i \in \Tid$ and $n \in \Q$.
      \end{itemize}
      Given this representation one could restore some piece of the event structure notation, 
      in particular:
      \begin{itemize}
        \item $\lEi \defeq \{e \in E ~|~ \exists{x} \in \Loc ~.~ e = \tup{\lINIT~x}\}$;
        \item $\lTID : \fun{\lE}{\Tid}$ s.t. \\
          $\forall{e} ~.~ (e = \tup{\lINIT~x} \implies \lTID(e) = 0) \wedge 
           (e = \tup{i, n} \Rightarrow \lTID(e) = i)$;
        \item $\lPO \subseteq \lE \times \lE$ s.t. \\
          $\tup{e_1, e_2} \in \lPO \iff (e_1 \in \lEi \wedge e_2 \not\in \lEi) \vee 
           (e_1 \not\in \lEi \wedge e_2 \not\in \lEi \wedge \lTID(e_1) = \lTID(e_2) \wedge
            \lSN(e_1) < \lSN(e_2))$, 
          where $\lSN(\tup{i, n}) = n$.
      \end{itemize}
      \item $\lLAB, \lMOD, \lRMW, \lRF, \lMO$ have the same definitions
        as in the event structure model.
      \item $\lDATA \subseteq \lR \times \lW$ --- data dependency;
      \item $\lADDR \subseteq \lR \times (\lR \cup \lW)$ --- address dependency;
      \item $\lCTRL \supseteq \lCTRL; \lPO$ --- control dependency;
      \item $\lCASDEP \subseteq [R];\lPO;[R^{\Ex}]$ --- CAS dependency;
  \end{itemize}
\end{definition}

\begin{definition}
  A function $O_{\lG} : \Loc \fun \Val$ is an \emph{outcome} of an \imm execution graph $\lG$
  if for every $x \in \Loc$ either $O_{\lG}(x) = \lG.\lVALW(w)$ 
  for some $\lG.\lMO$-maximal write event $w$, 
  or $O_{\lG} = 0$ and $\lG.\lW_x = \emptyset$.
\end{definition}

\section{Compilation correctness}

\begin{theorem}
  For every consistent \imm execution graph $G$
  there exists a consistent event structure $\lES$ and its consistent execution $\lX$
  such that an outcome of execution graph $O_{\lG}$ matches
  an outcome of events structure's execution $O_{\lX}$, 
  that is $O_{\lG} = O_{\lX}$.
\end{theorem}

\subsection{Traversal}

\begin{definition}
  A traversal configuration of an execution graph $\lG$ is a pair $\tup{\lC, \lI}$, 
  where $\lC \subseteq \lG.\lE$ is a set of \emph{covered} events 
  and $\lI \subseteq \lG.\lW$ is a set of \emph{issued} events,
  that additionally satisfies the following properties:
  \begin{itemize}
    \item $\lG.\lEi \subseteq \lC$;
    \item $\lC \cap \lG.\lW \subseteq \lI$;
    \item $\lC \subseteq \lCOVERABLE(\lG, \lC, \lI)$;
    \item $\lI \subseteq \lISSUABLE(\lG, \lC, \lI)$;
  \end{itemize}
  Configuration is called \emph{initial} when $\lC = \lI = \lG.\lEi$.
\end{definition}

\begin{definition}
  A write event $w \in \lG.\lW$ is \emph{issuable} in $\lG$ and $\tup{\lC, \lI}$,
  denoted $w \in \lISSUABLE(\lG, \lC, \lI)$, 
  if the following conditions are met:
  \begin{itemize}
    \item $\dom{([\lG.\lW^{rel}];\lmakeLoc{\lG.\lPO} \cup [\lG.\lF];\lG.\lPO);[w]} \subseteq \lC$
    \item $\dom{(\lG.\lDETOUR \cup \lG.\lRFE);\lG.\lPPO;[w]} \subseteq \lI$
    \item $\dom{(\lG.\lDETOUR \cup \lG.\lRFE);[\lG.R^{acq}];\lG.\lPO;[w]} \subseteq \lI$
  \end{itemize}
\end{definition}

\begin{definition}
  An event $e \in \lG.\lE$ is \emph{coverable} in $\lG$ and $\tup{\lC, \lI}$,
  denoted $e \in \lCOVERABLE(\lG, \lC, \lI)$, 
  if $\dom{\lG.\lPO;[e]} \subseteq \lC$ and either:
  \begin{itemize}
    \item $e \in \lG.\lW \cap \lI$
    \item $e \in \lG.\lR \wedge \dom{\lG.\lRF;[e]} \subseteq I$
    \item $e \in \lG.\lF^{\sqsubset\sco}$
    \item $e \in \lG.\lF^{\sco} \wedge \dom{\lG.\lSC;[e]} \subseteq \lC$
  \end{itemize}
\end{definition}

\begin{figure}[thb]

\small
    
    \begin{center}
    \AxiomC{$e \in \lCOVERABLE(\lG, \lC, \lI)$}
    \UnaryInfC{$
      \lG \vdash \tup{\lC, \lI} \rightarrow \tup{\lC \uplus \{e\}, \lI}
    $}
    \DisplayProof
    % 
    \rulehskip
    % 
    \AxiomC{$w \in \lISSUABLE(\lG, \lC, \lI)$}
    \UnaryInfC{$
      \lG \vdash \tup{\lC, \lI} \rightarrow \tup{\lC, \lI \uplus \{w\}}
    $}
    \DisplayProof
    \end{center}
    
    \caption{Traversal step relation}
    \label{fig:traversal-rules}
\end{figure}

\subsection{Simulation relation}

\begin{definition}
  Simulation relation $\lSIM(\lES, \lG, \tup{\lC, \lI})$ that binds an 
  event structure $\lES$, an \imm execution graph $\lG$ and 
  a traversal configuration $\tup{\lC, \lI}$,
  holds if there exists two injecive mappings between events 
  $\lMC, \lM : \lG.\lE \fun \lES.\lE$
  such that the following conditions are met:
  \begin{enumerate}[label=\textbf{S.\arabic*}]
    \item \label{item:sim-lab}
      $\forall{e \in \lC} ~.~ \lG.\lLAB(e) = \lES.\lLAB(\lMC(e)) \wedge
       \forall{e \in \lI} ~.~ \lG.\lLAB(e) = \lES.\lLAB(\lMI(e))$;
    \item \label{item:sim-vis} 
      $\forall{e \in \lC \cup \lI} ~.~ \lM(e) \in \lVIS(\lES)$;
      \note{I am afraid that we cannot prove this.
        See the cover read case of proof for details.
        Instead I propose to use Lemma \ref{lemma:2}.
      }
    \item \label{item:sim-po} 
      $\lES.\lPO;[\lMC(\lC)] \subseteq [\lMC(\lC)];\lES.\lPO;[\lMC(\lC)]$;
    \item \label{item:sim-rf} 
      $\forall{\tup{w, r} \in [\lI];\lG.\lRF;[\lC]} ~.~ \tup{\lMI(w), \lMC(r)} \in \lES.\lRF$;
    \item \label{item:sim-ew} 
      $\forall{w \in \lC} ~.~ \tup{\lMI(w), \lMC(w)} \in \lES.\lEW$;
    \item \label{item:sim-mo}
      $\forall{\tup{w, w'} \in [\lC];\lG.\lMO;[\lC]} ~.~ \tup{\lMC(w), \lMC(w')} \in \lES.\lMO$;
  \end{enumerate}
\end{definition}

\begin{lemma}
  Given an event structure $\lES$, an \imm execution graph $\lG$ 
  and its traversal configuration $\tup{\lC, \lI}$
  if the relation $\lSIM(\lES, \lG, \tup{\lC, \lI})$ holds and 
  there exists $\tup{\lC', \lI'}$ s.t. $\lG \vdash \tup{\lC, \lI} \rightarrow \tup{\lC', \lI'}$
  then there exists $\lES'$ s.t. $\lSIM(\lES', \lG, \tup{\lC', \lI'})$ 
\end{lemma}

\begin{proof}
  
  Note, that according to rules of traversal step relation (fig.~\ref{fig:traversal-rules})
  the traversal adds one covered or one issued event at one step.
  In order to build an updated event mappings $\lMC'$, $\lMI'$ 
  and event structure $\lES'$ 
  when traversing a new event $e$ in the configuration $\tup{\lC, \lI}$
  we will define simulation step relation 
  $\tup{\lMC, \lMI, \lES} \xrightarrow{\lG, \lC, \lI, e} \tup{\lMC', \lMI', \lES'}$.
  Simulation step relation is defined according to rules in fig.~\ref{fig:simrules}.
  Auxiliary relation 
  $(\lM, \lES_{base}) \xRightarrow{\lG, e} (\lM', \lES'_{base})$,
  called basic simulation step, 
  is used to update event mapping and some components of event structure
  (fig.~\ref{fig:simrules-base}).
  Our goal then is to prove that $\lSIM(\lES', \lG, \tup{\lC', \lI'})$ holds.
  Again, as the traversal adds one covered or one issued event at one step,
  we basically need to show that \ref{item:sim-lab}-\ref{item:sim-mo} hold
  for that added event.

  First, suppose that 
  $\lG \vdash \tup{\lC, \lI} \rightarrow \tup{\lC \uplus \{e\}, \lI}$ for some $e$.
  \ref{item:sim-lab} follow from the definition of the basic simulation step.
  In order to prove other properties of simulation relation,
  we have to consider different cases.

  \begin{itemize}
    \item $e$ is a non-sc fence event, that is $e \in \lG.\lF^{\sqsubset\sco}$.
      \ref{item:sim-po} follows from the $\lSIM(\lES, \lG, \tup{\lC, \lI})$ 
      and the definition of $\lCOVERABLE$.
      \ref{item:sim-ew} follows from the fact that
      we did not modify the set of covered writes on this step.
      As fences do not contribute neither to the $\lRF$ relation, neither to the $\lMO$, 
      \ref{item:sim-rf}, and \ref{item:sim-mo} follows immediately.
      Since $e$ is a fence event, $\hat{e}$ cannot have incoming $\lRF$ edges,
      and thus for any conflicting write $\hat{w}$ that $\hat{e}$ depend on
      the last edge in a $\lPO \cup \lRF$ dependency path is a $\lPO$ edge.
      But since $\lSIM(\lES, \lG, \lC, \lI)$ holds we know that 
      any $\lPO$-predcessor of $\hat{e}$ is visible, and thus $\hat{e}$ is also visible.
      We have proven \ref{item:sim-vis}.

    \item $e$ is a write event, that is $e \in \lG.\lW$.
      \ref{item:sim-po} and \ref{item:sim-vis} can be proven similarly 
      to the case when $e$ is a non-sc fence.
      Since $e$ is a write, it cannot have any incoming $\lRF$ edges and thus
      the \ref{item:sim-rf} follows directly from 
      the fact that $\lSIM(\lES, \lG, \tup{\lC, \lI})$ holds.
      \ref{item:sim-ew} and \ref{item:sim-mo} follow from the construction
      of $\lEW'$ and $\lMO'$ in (COVER-WRITE) rule.
      %% To prove \ref{item:sim-rf-c} consider a read $r \in \lC$ that reads from $e$,
      %% that is $\tup{e, r} \in \lG.\lRF$.
      %% From the definition of $\lCOVERABLE$ we know that $e \in I$,
      %% and thus $\tup{e, r} \in [\lI];\lG.\lRF;[\lC]$.
      %% Then from \ref{item:sim-rf-i} we can conclude that $\tup{\lMI(e), \lMC(r)} \in \lES.\lRF$.
      %% According to (COVER-WRITE) rule\footnote{\note{ask Anton how to make reference to rules}}
      %% $\tup{\hat{e}, \lMI(e)} \in \lEW'$
      %% and thus $\tup{\hat{e}, \lMC(r)} \in \lES'.\lJF$.
      
    \item $e$ is a read event, that is $e \in \lG.\lR$.
      Again \ref{item:sim-po} can be proven similarly to the previous cases.
      \ref{item:sim-ew} follows from the fact that
      we did not modify the set of covered writes on this step.
      \ref{item:sim-mo} holds because read events do not contribute to the $\lMO$.
      From the definition of $\lCOVERABLE$ we know that for write $w \in \lG.\lW$
      that $e$ read from, that is $\tup{w, e} \in \lG.\lRF$, $w \in I$.
      From that and the (COVER-READ) rule we can conclude that \ref{item:sim-rf} holds.
      \note{further go my speculations}.
      As for \ref{item:sim-vis} note that after we added $e$ into $\lC$,
      new conflicting writes that $e$ depends on may appear.
      Unlike the cases when $e$ is a write or a fence,
      the last edge in a dependency path not necessary a $\lPO$ edge,
      it might be an $\lRFE$ edge.
      That is, we might have events $w, w'$, such that
      $\tup{w, w'} \in (\lPO \cup \lRF)^+$,
      $\tup{w', e} \in \lRFE$ and $\tup{w, e} \in \lCF$.
      If $w$ not covered, that is $w \in \lI \setminus \lC$,
      then we can conclude that $\tup{e, w} \in \lPO$ in execution graph,
      that is the read $e$ reads from a write that depends on some promised write
      from the same thread.
      In order to support invariant \ref{item:sim-vis} we have to
      cover all events up to $w$ at this step.
      Alternatively we can give up on maintaining this property
      and use Lemma \ref{lemma:2} instead.


%    \item $e \in \lG.\lF^{\sco} \wedge \dom{\lG.\lSC;[e]} \subseteq \lC$
  \end{itemize}
\end{proof}

\begin{figure}[thb]

\begin{subfigure}{1\textwidth}

\small

    \begin{center}
    \AxiomC{$\hat{e} = max(\lE) + 1$}
    \noLine
    \UnaryInfC{$E' = \lE \cup \{\hat{e}\}$}
    \noLine
    \UnaryInfC{$\lM' = \lM[e \rightarrow \hat{e}]$}

    \AxiomC{$\lTID' = \lTID[\hat{e} \rightarrow \lG.\lTID(e)]$}
    \noLine
    \UnaryInfC{$\lLAB' = \lLAB[\hat{e} \rightarrow \lG.\lLAB(e)]$}
    \noLine
    \UnaryInfC{$\lMOD' = \lMOD[\hat{e} \rightarrow \lG.\lMOD(e)]$}

    \BinaryInfC{$
      (\lM, \tup{\lE, \lTID, \lLAB, \lMOD})
      \xRightarrow{\lG, e}
      (\lM', \tup{\lE', \lTID', \lLAB', \lMOD'})
    $}
    \DisplayProof
    \end{center}
    
\caption{Basic simulation step}
\label{fig:simrules-base}
\end{subfigure}

\begin{subfigure}{1\textwidth}
    
\small

    \begin{subfigure}{1\textwidth}
    [COVER-FENCE]
    \begin{center}
      \AxiomC{$(\lMC, \lES_{base}) \xRightarrow{\lG, e} (\lMC', \lES'_{base})$}
      \noLine
      \UnaryInfC{$e \in \lG.\lF^{\sqsubset\sco} \cap \lCOVERABLE(\lG, \lC, \lI)$}

      \AxiomC{$\lPO' = \lPO \cup \lMC'([\lC];\lG.\lPO;[e])$}
      \BinaryInfC{$
        \tup{\lMC, \lMI, \lES_{base}, \lPO, \lRMW, \lRF, \lEW, \lMO}
        \xrightarrow{\lG, \lC, \lI, e}
        \tup{\lMC', \lMI, \lES'_{base}, \lPO', \lRMW, \lRF, \lEW, \lMO}
        $}
      \DisplayProof
    \end{center}
    \label{fig:simrule-fence-cover}
    \end{subfigure}

    \begin{subfigure}{1\textwidth}
    [COVER-WRITE]
    \begin{center}
      \AxiomC{$(\lMC, \lES_{base}) \xRightarrow{\lG, e} (\lMC', \lES'_{base})$}
      \noLine
      \UnaryInfC{$e \in \lG.\lW \cap \lCOVERABLE(\lG, \lC, \lI)$}
      
      \AxiomC{$\lPO' = \lPO \cup \lMC'([\lC];\lG.\lPO;[e])$}
      \noLine
      \UnaryInfC{$\lMO' = \lMO \cup \lMC'([\lC];\lG.\lMO;[e]) \cup \lMC'([e];\lG.\lMO;[\lC])$}
      \noLine
      \UnaryInfC{$\lEW' = \lEW \cup \{\tup{\lMC'(e), \lMI(e)}, \tup{\lMI(e), \lMC'(e)}\}$}
      \BinaryInfC{$
        \tup{\lMC, \lMI, \lES_{base}, \lPO, \lRMW, \lRF, \lEW, \lMO}
        \xrightarrow{\lG, \lC, \lI, e}
        \tup{\lMC', \lMI, \lES'_{base}, \lPO', \lRMW, \lRF, \lEW', \lMO'}
        $}
      \DisplayProof
    \end{center}
    \label{fig:simrule-write-cover}
    \end{subfigure}

    \begin{subfigure}{1\textwidth}
    [COVER-READ]
    \begin{center}
      \AxiomC{$(\lMC, \lES_{base}) \xRightarrow{\lG, e} (\lMC', \lES'_{base})$}
      \noLine
      \UnaryInfC{$e \in \lG.\lR \cap \lCOVERABLE(\lG, \lC, \lI)$}
      
      \AxiomC{$\lPO' = \lPO \cup \lMC'([\lC];\lG.\lPO;[e])$}
      \noLine
      \UnaryInfC{$\lRF' = \lRF \cup \{\tup{\lMI(w), \lMC'(e)} ~|~ \tup{w, e} \in \lG.\lRF \} $}
      \BinaryInfC{$
        \tup{\lMC, \lMI, \lES_{base}, \lPO, \lRMW, \lRF, \lEW, \lMO}
        \xrightarrow{\lG, \lC, \lI, e}
        \tup{\lMC', \lMI, \lES'_{base}, \lPO', \lRMW, \lRF', \lEW, \lMO}
        $}
      \DisplayProof
    \end{center}
    \label{fig:simrule-read-cover}
    \end{subfigure}

    \begin{subfigure}{1\textwidth}
    [ISSUE-WRITE]
    \begin{center}
      \AxiomC{$e \in \lISSUABLE(\lG, \lC, \lI)$}
      \noLine
      \UnaryInfC{$\lG^{crt} = \lCERTIFY(\lG, e)$}
      \noLine
      \UnaryInfC{$(\lMI, \lES_{base}) \xRightarrow{\lG, (e_1, \dots, e_n)} (\lMI', \lES'_{base})$}
      \noLine
      \UnaryInfC{$\lG^{crt} \vdash \tup{\lC, \lI} \xrightarrow{(e_1, \dots, e_n)} \tup{\lC^{crt}, \lI^{crt}}$}

      \AxiomC{$\lC^{diff} = \lC^{crt} \setminus \lC$}
      \noLine
      \UnaryInfC{$\lPO' = \lPO \cup \lMI'([\lC^{diff}];\lG^{crt}.\lPO;[\lC^{diff}])$}
      \noLine
      \UnaryInfC{$\lRF' = \lRF \cup \lMI'([\lC^{diff}];\lG^{crt}.\lRF;[\lC^{diff}])$}
      \noLine
      \UnaryInfC{$\lMO' = \lMO \cup \lMI'([\lC^{diff}];\lG^{crt}.\lMO;[\lC^{diff}])$}
      
      \BinaryInfC{$
        \tup{\lMC, \lMI, \lES_{base}, \lPO, \lRMW, \lRF, \lEW, \lMO}
        \xrightarrow{\lG, \lC, \lI, e}
        \tup{\lMC, \lMI', \lES'_{base}, \lPO', \lRMW, \lRF', \lEW, \lMO'}
        $}
      \DisplayProof
    \end{center}
    \label{fig:simrule-write-issue}
    \end{subfigure}
    
    \caption{Simulation step}
    \label{fig:simrules}
\end{subfigure}

\end{figure}


\begin{lemma}
  \label{lemma:2}
  Given an event structure $\lES$, an \imm execution graph $\lG$ 
  and its traversal configuration $\tup{\lC, \lI}$
  if the relation $\lSIM(\lES, \lG, \tup{\lC, \lI})$ holds
  then for any covered event $e \in \lC$ and any
  write from its masking set $w \in \lMASK(\lG, \hat{e})$
  there exist $\lES', \lC', \lI'$ such that
  $\lG \vdash \tup{\lC, \lI} \rightarrow^* \tup{\lC', \lI'}$, 
  $\lSIM(\lES', \lG, \tup{\lC', \lI'})$
  and $\tup{w, \hat{e}} \in \lES'.\lEW;\lES'.\lPO^=$.
  \note{Probably, $\lI = \lI'$ ?}
\end{lemma}

\begin{lemma}
  \label{lemma:3}
  Given an event structure $\lES$, an \imm execution graph $\lG$ 
  and its traversal configuration $\tup{\lC, \lI}$
  if the relation $\lSIM(\lES, \lG, \tup{\lC, \lI})$ holds
  then there exists $\lES', \lC', \lI'$ and event structure execution $\lX$ such that
  $\lG \vdash \tup{\lC, \lI} \rightarrow^* \tup{\lC', \lI'}$
  and $\lX$ satisfies the following conditions.
  \begin{itemize}
  \item $\lX.\lE = \lMC(C')$
  \item $\lX.\lPO = \lMC([\lC'];\lG.\lPO;[\lC'])$
  \item $\lX.\lRMW = \lMC([\lC'];\lG.\lRMW;[\lC'])$
  \item $\lX.\lRF = \lMC([\lC'];\lG.\lRF;[\lC'])$
  \item $\lX.\lMO = \lMC([\lC'];\lG.\lMO;[\lC'])$    
  \end{itemize}
\end{lemma}

\setmonofont[Mapping=tex-text]{CMU Typewriter Text}
\bibliographystyle{acm}
\bibliography{main.bib}

\end{document}
