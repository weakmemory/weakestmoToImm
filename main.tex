\documentclass[12pt]{article}
\usepackage{fontspec}
\usepackage{xcolor}
\usepackage{listings}
\usepackage[justification=centering]{caption}
\usepackage{subcaption}
\usepackage{cite}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{bussproofs}
\usepackage{tikz}
\usepackage{float}
\usepackage{graphicx}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{array}
\usepackage{stmaryrd}
\usepackage{pifont}
\usepackage{enumitem}
\usepackage{extarrows}

\input{defs.tex}

\begin{document}

\begin{center}
{\center \LARGE Compiling Event Structures to the Intermediate Memory Model }
\end{center}

\section{Event Structure Model}

\begin{definition}
  An \emph{event structure} $\lES$ is a tuple
  $\tup{\lE, \lEi, \lTID, \lLAB, \lMOD, \lPO, \lRMW, \lRF, \lEW, \lMO}$ where:
  \begin{itemize}
  \item $\lE \subseteq \N$ --- finite set of events. 
  \item $\lEi \subseteq \lE$ --- initialization events.
  \item $\lTID \defeq \lE \fun \Tid$ --- function that assigns a thread id to every event.
    Given thread id $i \in \Tid$ we will denote by $\lE_i$ the set of all events belonging 
    to $i^{th}$ thread, that is $\lE_i \defeq \{e \in \lE ~|~ \lTID(e) = i\}$.
    We assume that if $e \in \lEi$ then $\lTID(e) = 0$.
  \item $\lLAB \defeq \lE \fun \Lab$ --- function that assigns a label to every event.
    Labels are of one of the following forms:
    \begin{itemize}
    \item $\rlabExExpl{x}{v}{\mathtt{f}}$ --- a read, where $x \in \Loc$, $v \in \Val$ 
      and $\mathtt{f} \in \{\Ex, \NotEx\}$ is an exclusive flag 
      (we will denote exclusive reads as $\rlabEx{x}{v}$,
       for non-exclusive reads we will omit the flag);
    \item $\wlab{x}{v}$ --- a write, where $x \in \Loc$, $v \in \Val$;
    \item $\flab$ --- a fence.
    \end{itemize}
    $\lLAB$ induces the following functions:
    \begin{itemize}
    \item $\lTYP \defeq \lE \fun \{\lR, \lW, \lF\}$ --- assigns a type to every event;
    \item $\lLOC \defeq \lE \pfun \Loc $ --- returns the location of event (when applicable);
    \item $\lVALR \defeq \lE \pfun \Val$ --- returns the read value of event (when applicable);
    \item $\lVALW \defeq \lE \pfun \Val$ --- returns the written value of event (when applicable).
    \end{itemize}
    We assume that $\forall{e} \in \lEi. \; \lLAB(e) = \wlab{x}{0}$.
  \item A function $\lMOD = G.\lE \rightarrow \Mod$ is a memory order assignment.
    Elements of the set $\Mod \defeq \{ \rlx, \rel, \acq, \acqrel, \sco \}$ are
    called \emph{memory order} parameters.
    Additionally, $\lMOD$ satisfies the following constraints:
    \begin{itemize}
    \item $e \in \lR \Rightarrow \lMOD(e) \in \{ \rlx, \acq, \sco \}$;
    \item $e \in \lW \Rightarrow \lMOD(e) \in \{ \rlx, \rel, \sco \}$;
    \item $e \in \lF \Rightarrow \lMOD(e) \in \{ \rlx, \acqrel, \sco \}$.
    \end{itemize}
  \item $\lPO \subseteq \lE \times \lE$ --- \emph{program order}, which is a strict partial order.
    It orders all initialization events before all other events,
    that is $\lEi \times (\lE \setminus \lEi) \subseteq \lPO$.
    Moreover, $\lPO$ induces the \emph{conflict relation} $\lCF$.
    \begin{itemize}
      \item  $\lCF \defeq \lPO^{-1};[E];\lPO \setminus \lPO^{=}$.
    \end{itemize}
  \item $\lRMW \subseteq [\lR];(\lPO_{imm} \cap =_{loc});[\lW]$ ---
    \emph{read-modify-write pairs}.
  \item $\lRF \subseteq \lW; =_{loc}; \lR$ --- \emph{reads-from} relation, which the following
    hold for:
    \begin{itemize}
    \item $\forall{\tup{a, b}} \in \lRF. \; \lVALW(a) = \lVALR(b)$;
    \item $\forall{a_1, a_2, b}. \; \tup{a_1, b} \in \lRF \wedge \tup{a_2, b} \in \lRF \Rightarrow a_1 = a_2.$
    \end{itemize}
  \item $\lEW \subseteq \lW \times \lW$ --- is the \emph{equal write} relation, 
    which is an irreflexive, symmetric and transitive relation between conflicting writes on the
    same location writing same values 
    (that is $\lEW(e_1, e_2) \Rightarrow \lVALW(e_1) = \lVALW(e_2)$).
    Given $\lRF$, $\lEW$ and $\lCF$ we will also define a derived \emph{justified from} relation:
    \begin{itemize}
      \item $\lJF \defeq \lEW^?;\lRF \setminus \lCF$
    \end{itemize}
  \item $\lMO \subseteq \lW \times \lW$ --- \emph{modification order}, which is a strict partial order.
  \end{itemize}
\end{definition}

\begin{definition}
  Using the primitive relations of an event structure $\lES$,
  we define following derived relations:
  \begin{itemize}
    \item $\lES.\lRB \defeq (\lES.\lJF^{-1};\lES.\lMO) \setminus \lES.\lCF^?$ --- 
      \emph{reads before};
    \item $\lES.\lECO \defeq (\lES.\lJF \cup \lES.\lRB \cup \lES.\lMO)^+$ --- 
      \emph{extended coherence order}.
  \end{itemize}
\end{definition}

\begin{definition}
  Giving an event structure $\lES$ we define the \emph{happens-before} relation $\lHB$
  using auxililarly relations: 
  $\lRSEQ$ --- release sequence,
  $\lRELP$ --- release prefix and
  $\lSW$ --- synchronize-with.
  \begin{itemize}
  \item $\lRSEQ \defeq [\lWsqeq{rlx}];(\lmakeLoc{\lPO};[\lWsqeq{rlx}] \cup 
    (\lmakeLoc{\lPO^?};[\lWsqeq{\rlx}];\lJF;\lRMW)^*)$;
  \item $\lRELP \defeq [\lEsqeq{rel}];([\lW] \cup [\lF];\lPO);\lRSEQ$;
  \item $\lSW \defeq \lRELP; (\lRFI \cup \lmakeLoc{\lPO^?};\lRFE); [\lR \cup \lPO;[\lF]);[\lEsqeq{\acq}]$;
  \item $\lHB \defeq (\lPO \cup \lSW)^+$.
  \end{itemize}
\end{definition}

\begin{definition}
  For an event $e$ from an event structure $\lES$
  the \emph{masking set} of $e$, denoted as $\lMASK(\lES, e)$,
  is a set of conflicting write events that $e$ depends on.
  This set is called masking, because its elements might make an event $e$ \emph{invisible}.
  \begin{itemize}
  \item $\lMASK(\lES, e) \defeq
    \{w \in \lES.\lW ~|~ \tup{w, e} \in \lES.\lCF \cap (\lES.\lPO \cup \lES.\lRF)^+ \}$
  \end{itemize}
\end{definition}

\begin{definition}
  For an event structure $\lES$ the set of its visible events $\lVIS(\lES)$ defined as follow:
  \begin{itemize}
    \item $\lVIS(\lES) \defeq 
      \{ e \in \lES ~|~ \lES.\lW;(\lES.\lCF \cap (\lES.\lPO \cup \lES.\lRF)^+);[e] \subseteq 
         \lES.\lEW;\lES.\lPO^=
      \}$,
  \end{itemize}
  or equivalently:
  \begin{itemize}
    \item $\lVIS(\lES) \defeq 
      \{ e \in \lES ~|~ \forall{w \in \lMASK(\lES, e)} ~.~ \tup{w, e} \in \lES.\lEW;\lES.\lPO^=\}$.
  \end{itemize}
\end{definition}

\begin{definition}
  Given an event structure $\lES$ we will a call a tuple $\tup{\lE, \lPO, \lRMW, \lRF, \lMO}$ 
  its \emph{execution} $\lX$ if the following conditions hold:
  \begin{itemize}
    \item $\lX.\lE \subseteq \lVIS(\lES)$;
    \item $[\lX.\lE];\lES.\lCF;[\lX.\lE] = \emptyset$;
    \item $\lES.\lPO;[\lX.\lE] \subseteq \lX.\lE \times \lX.\lE$;
    \item $\forall{\tup{e, e'}} \in (\lX.\lE;\lES.\lPO;[\lES.\lE \setminus \lX.\lE]) ~.~ 
      \exists{e''} \in \lX.\lE ~.~ \tup{e', e''} \in \lES.\lCF$;
    \item $\lX.\lPO = [\lX.\lE];\lES.\lPO;[\lX.\lE]$;
    \item $\lX.\lRMW = [\lX.\lE];\lES.\lRMW;[\lX.\lE]$;
    \item $\lX.\lRF = [\lX.\lE];\lES.\lJF;[\lX.\lE]$;
    \item $\lX.\lMO = [\lX.\lE];\lES.\lMO;[\lX.\lE]$.
  \end{itemize}
\end{definition}

\begin{definition}
  A function $O_{\lX} : \Loc \fun \Val$ is an \emph{outcome} 
  of an event structure's $\lES$ execution $\lX$
  if for every $x \in \Loc$ either $O_{\lX}(x) = \lES.\lVALW(w)$ 
  for some $\lX.\lMO$-maximal write event $w$, 
  or $O_{\lG} = 0$ and $\lX.\lW_x = \emptyset$.
\end{definition}

\section{Intermediate Memory Model}

\begin{definition}
  An \imm execution graph $\lG$ is a tuple \\
  $\tup{\lE, \lLAB, \lMOD, \lRMW, \lRF, \lMO, \lDATA, \lADDR, \lCTRL, \lCASDEP}$ where:
  \begin{itemize}
    \item $\lE$ is a set of events. 
      Events in \imm have different representation comparing to the event structure model. 
      That is, an event is either:
      \begin{itemize}
        \item an \emph{initialization} event $\tup{\lINIT~x}$ where $x \in \Loc$;
        \item a \emph{non-initialization} event $\tup{i, n}$ where $i \in \Tid$ and $n \in \Q$.
      \end{itemize}
      Given this representation one could restore some piece of the event structure notation, 
      in particular:
      \begin{itemize}
        \item $\lEi \defeq \{e \in E ~|~ \exists{x} \in \Loc ~.~ e = \tup{\lINIT~x}\}$;
        \item $\lTID : \fun{\lE}{\Tid}$ s.t. \\
          $\forall{e} ~.~ (e = \tup{\lINIT~x} \implies \lTID(e) = 0) \wedge 
           (e = \tup{i, n} \Rightarrow \lTID(e) = i)$;
        \item $\lPO \subseteq \lE \times \lE$ s.t. \\
          $\tup{e_1, e_2} \in \lPO \iff (e_1 \in \lEi \wedge e_2 \not\in \lEi) \vee 
           (e_1 \not\in \lEi \wedge e_2 \not\in \lEi \wedge \lTID(e_1) = \lTID(e_2) \wedge
            \lSN(e_1) < \lSN(e_2))$, 
          where $\lSN(\tup{i, n}) = n$.
      \end{itemize}
      \item $\lLAB, \lMOD, \lRMW, \lRF, \lMO$ have the same definitions
        as in the event structure model.
      \item $\lDATA \subseteq \lR \times \lW$ --- data dependency;
      \item $\lADDR \subseteq \lR \times (\lR \cup \lW)$ --- address dependency;
      \item $\lCTRL \supseteq \lCTRL; \lPO$ --- control dependency;
      \item $\lCASDEP \subseteq [R];\lPO;[R^{\Ex}]$ --- CAS dependency;
  \end{itemize}
\end{definition}

\begin{definition}
  A function $O_{\lG} : \Loc \fun \Val$ is an \emph{outcome} of an \imm execution graph $\lG$
  if for every $x \in \Loc$ either $O_{\lG}(x) = \lG.\lVALW(w)$ 
  for some $\lG.\lMO$-maximal write event $w$, 
  or $O_{\lG} = 0$ and $\lG.\lW_x = \emptyset$.
\end{definition}

\section{Compilation correctness}

\begin{theorem}
  For every consistent \imm execution graph $G$
  there exists a consistent event structure $\lES$ and its consistent execution $\lX$
  such that an outcome of execution graph $O_{\lG}$ matches
  an outcome of events structure's execution $O_{\lX}$, 
  that is $O_{\lG} = O_{\lX}$.
\end{theorem}

\subsection{Traversal}

\begin{definition}
  A traversal configuration of an execution graph $\lG$ is a pair $\tup{\lC, \lI}$, 
  where $\lC \subseteq \lG.\lE$ is a set of \emph{covered} events 
  and $\lI \subseteq \lG.\lW$ is a set of \emph{issued} events,
  that additionally satisfies the following properties:
  \begin{itemize}
    \item $\lG.\lEi \subseteq \lC$;
    \item $\lC \cap \lG.\lW \subseteq \lI$;
    \item $\lC \subseteq \coverable(\lG, \lC, \lI)$;
    \item $\lI \subseteq \issuable(\lG, \lC, \lI)$;
  \end{itemize}
  Configuration is called \emph{initial} when $\lC = \lI = \lG.\lEi$.
\end{definition}

\begin{definition}
  A write event $w \in \lG.\lW$ is \emph{issuable} in $\lG$ and $\tup{\lC, \lI}$,
  denoted $w \in \issuable(\lG, \lC, \lI)$, 
  if the following conditions are met:
  \begin{itemize}
    \item $\dom{([\lG.\lW^{rel}];\lmakeLoc{\lG.\lPO} \cup [\lG.\lF];\lG.\lPO);[w]} \subseteq \lC$
    \item $\dom{(\lG.\lDETOUR \cup \lG.\lRFE);\lG.\lPPO;[w]} \subseteq \lI$
    \item $\dom{(\lG.\lDETOUR \cup \lG.\lRFE);[\lG.R^{acq}];\lG.\lPO;[w]} \subseteq \lI$
  \end{itemize}
\end{definition}

\begin{definition}
  An event $e \in \lG.\lE$ is \emph{coverable} in $\lG$ and $\tup{\lC, \lI}$,
  denoted $e \in \coverable(\lG, \lC, \lI)$, 
  if $\dom{\lG.\lPO;[e]} \subseteq \lC$ and either:
  \begin{itemize}
    \item $e \in \lG.\lW \cap \lI$
    \item $e \in \lG.\lR \wedge \dom{\lG.\lRF;[e]} \subseteq I$
    \item $e \in \lG.\lF^{\sqsubset\sco}$
    \item $e \in \lG.\lF^{\sco} \wedge \dom{\lG.\lSC;[e]} \subseteq \lC$
  \end{itemize}
\end{definition}

\begin{figure}[thb]

\small
    
    \begin{center}
    \AxiomC{$e \in \coverable(\lG, \lC, \lI)$}
    \UnaryInfC{$
      \lG \vdash \tup{\lC, \lI} \rightarrow \tup{\lC \uplus \{e\}, \lI}
    $}
    \DisplayProof
    % 
    \rulehskip
    % 
    \AxiomC{$w \in \issuable(\lG, \lC, \lI)$}
    \UnaryInfC{$
      \lG \vdash \tup{\lC, \lI} \rightarrow \tup{\lC, \lI \uplus \{w\}}
    $}
    \DisplayProof
    \end{center}
    
    \caption{Traversal step relation}
    \label{fig:traversal-rules}
\end{figure}

\subsection{Simulation relation}

\subsubsection{Basic simulation}

In this section we will present a relation $\simRb(S, G, \tup{C, I}, s, t)$.
It states some properties about labeling of events and $\lPO$ order in $G$ and $S$
that are preserved by $s$ and $t$. 
We will show that this relation is closed with respect to $\ESle$ order on event structures.
Moreover, we will provide a necessary conditions, that when preserved,
allow to add a new covered event to $C$ and still satisfy the relation.

\begin{definition}
  Relation $\simRb(S, G, \tup{C, I}, s, t)$, that binds an 
  event structure $S$, an \imm execution graph $G$,
  a traversal configuration $\tup{C, I}$,
  a source $s : G.\lE \fun S.\lE$ and target $t : S.\lE \fun G.\lE$ event mappings
  holds if the following conditions are met:
  \begin{enumerate}[label=\textbf{S.\arabic*}]
  \item \label{item:sim-dom-s}
    $\dom{s} \subseteq C \cup I$
  \item \label{item:sim-lab}
    $\forall{e \in C \cup I} ~.~ G.\lLAB(e) = S.\lLAB(s(e))$;
  \item \label{item:sim-cf}
    $\forall{e_1, e_2 \in C} ~.~ \tup{s(e_1), s(e_2)} \not\in S.\lCF$;
  \item \label{item:sim-po-prfx} 
    $S.\lPO;[s(\lC)] \subseteq [s(C)];S.\lPO$;
  \end{enumerate}
\end{definition}

\begin{prop}
  Forall $S$, $G$, $\tup{C, I}$, $s$, $t$ and $S'$
  such that $\simRb(S, G, \tup{C, I}, s, t)$ holds and $S \ESle S'$
  $\simRb(S', G, \tup{C, I}, s, t)$
\end{prop}

\begin{prop}
  Given $S$, $G$, $\tup{C, I}$, $s$, $t$
  if the relation $\simRb(S, G, \tup{C, I}, s, t)$ holds and 
  there exists $e \in G.\lE$ and $\hat{e} \in S.\lE$ s.t.
  \begin{itemize}
  \item $G \vdash \tup{C, I} \rightarrow \tup{C \uplus \{e\}, I}$,
  \item $S.\lLAB(\hat{e}) = G.\lLAB(e)$,
  \item $\tup{s(\front{C, \lTID(e)}), \hat{e}} \in S.\lPO_{imm}$
  \end{itemize}
  then $\simRb(S, G, \tup{C \uplus \{e\}, I}, s[e \mapsto \hat{e}], t[\hat{e} \mapsto e])$ holds. 
\end{prop}

\begin{proof}
  Let $C' = C \uplus \{e\}$, $s' = s[e \mapsto \hat{e}]$ and $t' = t[\hat{e} \mapsto e]$.
  Let us prove that all conditions for $\simRb(S, G, \tup{C', I}, s', t')$ are met. 
  \begin{itemize}
  \item \ref{item:sim-dom-s}
    Holds trivially.
  \item \ref{item:sim-lab}
    \begin{equation}
      \begin{split}
        & \forall{a \in (C \uplus \{e\}) \cup I} ~.~ G.\lLAB(a) = S.\lLAB(s'(a)) \iff \\
        & \forall{a \in C \cup I} ~.~ G.\lLAB(a) = S.\lLAB(s(a)) \wedge G.\lLAB(e) = S.\lLAB(s'(e))
      \end{split}
    \end{equation}
    First conjunct follows from the $\simRb(S, G, \tup{C, I}, s, t)$;
    second conjunct follows from the proposition's premise.

  \item \ref{item:sim-cf} \\
    We need to show that
    $\forall{a, b \in \lC \uplus \{e\}} ~.~ \tup{s'(a), s'(b)} \not\in S.\lCF$.
    Let us consider the opposite, that is
    $\exists{a, b \in \lC \uplus \{e\}} ~.~ \tup{s'(a), s'(b)} \in S.\lCF$.
    Giving that $\simRb(S, G, \tup{C, I}, s, t)$ holds,
    we can conclude that $a = e \vee b = e$.
    Let us suppose that $a = e$.
    Consider $c$ such that $\tup{c, e} \in G.\lPO_{imm}$.
    Because $e \in \coverable(G, C, \lI)$ we know that $c \in C$.
    From that and $\simRb(S, G, \tup{C, I}, s, t)$
    we can conclude that $\tup{s(b), s(c)} \not\in S.\lCF$.
    If $\tup{s(b), s(c)} \in S.\lPO$ then by transitivity of $S.\lPO$
    $\tup{s'(b), s'(e)} \in S.\lPO$
    which contradicts the fact that $\tup{s'(b), s'(e)} \in S.\lCF$.
    Otherwise $\tup{s(c), s(b)} \in S.\lPO$.
    But since $b \in C$ and thus $b \in \coverable{G, C, I}$,
    we can conclude that it shoud be the case that $e \in C$.
    But that contradicts $e \in \nextset(G, C)$.

  \item \ref{item:sim-po-prfx} \\
    
    \begin{equation*}
      \begin{split}
        &     S.\lPO;[s'(C \uplus \{e\})] \subseteq [s'(C \uplus \{e\})];S.\lPO \iff \\
        &\iff S.\lPO;[s(C)] \cup S.\lPO;[\hat{e}] \subseteq [s(C)];S.\lPO \cup [\hat{e}];S.\lPO
      \end{split}
    \end{equation*}

    $S.\lPO;[s(C)] \subseteq [s(C)];S.\lPO$ because $\simRb(S, G, \tup{C, I}, s, t)$ holds.
    Let us show that $S.\lPO;[\hat{e}] \subseteq [s(C)];S.\lPO$.
    Suppose there exists $\hat{a}$ s.t. $\tup{\hat{a}, \hat{e}} \in S.\lPO$ but
    $\hat{a} \not\in s(C)$.
    Since $\tup{s(\front(C, \lTID(e)), \hat{e}} \in S.\lPO_{imm}$
    it must be the case that $\tup{\hat{a}, s(\front(C, \lTID(e))} \in S.\lPO$.
    But $\front(C, \lTID(e)) \in C$ and thus from $\ref{item:sim-po-prfx}$
    follows that $\hat{a} \in s(C)$. Contradiction.
    
    %% Let us show that \\
    %% $[\lM'(\lC \uplus \{e\})];\lES'.\lPO;[\lM'(\lC \uplus \{e\})] =
    %% [\lM(\lC)];\lES.\lPO;[\lM(\lC)] \cup \lM'([\lC];\lG.\lPO;[e])$.
    
    %% \begin{equation*}
    %%   \begin{split}
    %%     &   [\lM'(\lC \uplus \{e\})];\lES'.\lPO;[\lM'(\lC \uplus \{e\})] = \\
    %%     &   [\lM'(\lC \uplus \{e\})];(\lES'.\lPO;[\lM(\lC)] \cup \lES'.\lPO;[\lM'(e)]) = \\
    %%     & = [\lM(\lC)];\lES'.\lPO;[\lM(\lC)] \cup [\lM(\lC)];\lES'.\lPO;[\lM'(e)] \cup \\
    %%     &     \cup [\lM'(e)];\lES'.\lPO;[\lM(\lC)] \cup [\lM'(e)];\lES'.\lPO;[\lM'(e)]
    %%   \end{split}
    %% \end{equation*}
    
    %% Because $\lES'.\lPO = \lES.\lPO \cup \lM'(\lG.\lPO;[e])$ we can further rewrite that.
    
    %% \begin{equation*}
    %%   \begin{split}
    %%     &   [\lM(\lC)];\lES'.\lPO;[\lM(\lC)] \cup [\lM(\lC)];\lES'.\lPO;[\lM'(e)] \cup \\
    %%     &     \cup [\lM'(e)];\lES'.\lPO;[\lM(\lC)] \cup [\lM'(e)];\lES'.\lPO;[\lM'(e)] = \\
    %%     & = [\lM(\lC)];\lES.\lPO;[\lM(\lC)] \cup \lM'([\lC];\lG.\lPO;[e])
    %%   \end{split}
    %% \end{equation*}
    
    %% Using that we can rewrite \ref{item:sim-po-prfx} as follows:

    %% \begin{equation*}
    %% \lES.\lPO;[\lM(\lC)] \cup \lM'(\lG.\lPO;[e]) \subseteq
    %% [\lM(\lC)];\lES.\lPO;[\lM(\lC)] \cup \lM'([\lC];\lG.\lPO;[e])
    %% \end{equation*}
    
    %% $\lES.\lPO;[\lM(\lC)] \subseteq [\lM(\lC)];\lES.\lPO;[\lM(\lC)]$
    %% follows from the $\simRb(\lES, \lG, \tup{\lC, \lI}, \lM)$.
    %% $\lM'(\lG.\lPO;[e]) \subseteq \lM'([\lC];\lG.\lPO;[e])$ holds iff
    %% $\dom{\lG.\lPO;[e]} \subseteq \lC$, which is true,
    %% because $e \in \coverable(\lG, \lC, \lI)$.

  %% \item \ref{item:sim-po} \\
  %%   As we have already showed \\
  %%   $[\lM'(\lC \uplus \{e\})];\lES'.\lPO;[\lM'(\lC \uplus \{e\})] =
  %%   [\lM(\lC)];\lES.\lPO;[\lM(\lC)] \cup \lM'([\lC];\lG.\lPO;[e])$.
  %%   Thus we can prove the property for the two disjoint parts of the relation.
  %%   For the first part it follows from the $\simRb(\lES, \lG, \tup{\lC, \lI}, \lM)$.
  %%   For the second part it is obvious.
    
  \end{itemize}
  
\end{proof}

\begin{definition}
  Relation $\simRw(S, G, \tup{C, I}, s, t, \lPC)$, that binds an 
  event structure $S$, an \imm execution graph $G$,
  a traversal configuration $\tup{C, I}$,
  a source $s : G.\lE \fun S.\lE$ and target $t : S.\lE \fun G.\lE$ event mappings,
  a program counter $\lPC$
  holds whenever and $\simRb(S, G, \tup{C, I}, s)$ and
  additionally the following conditions are met:
  \begin{enumerate}[label=\textbf{S.\arabic*},start=5]
    \item \label{item:sim-dom-t}
      $\dom{t} = S.\lE$;
    \item \label{item:sim-typ-tid}
      $\forall{\hat{e} \in S.\lE} ~.~
      S.\lTYP(\hat{e}) = G.\lTYP(t(\hat{e})) \wedge
      S.\lTID(\hat{e}) = G.\lTID(t(\hat{e}))
      $;
    \item \label{item:sim-lab-tw}
      $\forall{\hat{e} \in S.\lW} ~.~ S.\lLAB(\hat{e}) = G.\lLAB(t(\hat{e}))$;
    \item \label{item:sim-po-imm}
      $\forall{\tup{\hat{e_1}, \hat{e_2}} \in S.\lPO_{imm}} ~.~
       \tup{t(\hat{e_1}), t(\hat{e_2})} \in G.\lPO_{imm}$;
    \item \label{item:sim-rf} 
      $\forall{\tup{w, r} \in [\lI];\lG.\lRF;[\lC]} ~.~ \tup{s(w), s(r)} \in \lES.\lJF$;
    \item \label{item:sim-jf}
      $
      \forall{\tup{\hat{w}, \hat{r}} \in \lES.\lJF} ~.~
      \exists{w' \in \lC \cup \lI} ~.~ \tup{s(w'), \hat{r}} \in \lES.\lJF
      $;
    \item \label{item:sim-mo}
      $\forall{\tup{w, w'} \in [\lI];\lG.\lMO;[\lI]} ~.~ \tup{s(w), s(w')} \in \lES.\lMO$;
      
    \item \label{item:sim-vis}
      $\forall{e \in (C \cup I)} ~.~
      e \in \dom{G.\lPO^?;[\lPC(\lTID(e))]} \implies s(e) \in \lVIS(S)$;
  \end{enumerate}
\end{definition}

\begin{lemma}
  Given $\lES$, $\lG$, $\tup{\lC, \lI}$, $s$, $t$ and $\lPC$
  if the relation $\simRw(S, G, \tup{\lC, \lI}, s, t, \lPC)$ holds and 
  there exists $\tup{\lC', \lI'}$
  s.t. $\lG \vdash \tup{\lC, \lI} \rightarrow \tup{\lC', \lI'}$
  then there exists $S'$, $s'$ and $t'$ s.t. $\lG \vdash (s, t, S) \ESstepstar (s', t', S')$
  and $\simRw(S', G, \tup{\lC', \lI'}, s', t', \lPC)$ 
\end{lemma}

\begin{proof}
  First, suppose that 
  $\lG \vdash \tup{\lC, \lI} \rightarrow \tup{\lC \uplus \{e\}, \lI}$ for some $e$.
  If there exists $\hat{e} \in S$ s.t. $S.\lLAB(\hat{e}) = G.\lLAB(e)$ and 
  $\tup{s(\front(C, \lTID(e))), \hat{e}} \in S.\lPO_{imm}$
  then the premises of $\ref{prop:2}$ are met and we can apply it.
  From $\ref{prop:2}$ follows that $\simRb(S, G, \tup{C', I}, s')$,
  where $s' = s[e \mapsto \hat{e}]$ holds.
  Let $t' = t$. Obviously \ref{item:sim-dom-t}-\ref{item:sim-po-imm} holds,
  because neither $S$ neither $t$ was modified. 
  We need to show that \ref{item:sim-dom-rf}-\ref{item:sim-vis-weak} holds.
  Let us consider different subcases:
  \begin{itemize}
  \item $e \in G.\lW$.
    \begin{itemize}

    \item \ref{item:sim-rf} \\
      We need to show that
      $\forall{\tup{w, r} \in [\lI];\lG.\lRF;[\lC \uplus\{e\}]} ~.~
      \tup{s(w), s(r)} \in \lES.\lJF
      $.
      $\tup{w, r} \in [\lI];\lG.\lRF;[\lC \uplus\{e\}] \iff
      \tup{w, r} \in [\lI];\lG.\lRF;[\lC] \cup  [\lI];\lG.\lRF;[e]
      $.
      For the first subset it follows from the $\simRw(S, G, \tup{\lC, \lI}, s, t, \lPC)$,
      the second subset is empty, since $e \in G.\lW$
      
    \item \ref{item:sim-mo} \\
      Holds trivially, since we did not modify $I$ on this step.

    \item \ref{item:sim-vis-weak} \\
      Let us show that $e \in \dom{G.\lPO^?;[\lPC(i)]}$, where $i = G.\lTID(e)$.
      By the definition of $e \in \Next(G, C)$ $\tup{\front(C, i), e} \in G.\lPO_{imm}$.
      By \ref{item:sim-pc} $\tup{\lPC(i), \front(C, i)} \in G.\lPO$.
      Thus $\tup{\lPC(i), e} \in G.\lPO$ and \ref{item:sim-vis-weak} holds.
    \end{itemize}
  \end{itemize}
  
  
  %% Let us consider different cases:
  %% \begin{itemize}
  %% \item $e \in \lG.\lW$. \\
  %%   Note that, from the definition of $\coverable$ follows that $e \in \lI$.
  %%   In this case we say that $\lES' = \lES$ and $\lM' = \lM$.
  %%   We need to show that \ref{item:sim-lab} - \ref{item:sim-vis}
  %%   holds for $\lES$, $\lG$, $\tup{\lC \uplus \{e\}, \lI}$, $\lM$.
  %%   \begin{itemize}
  %%   \item \ref{item:sim-lab} \\
  %%     From the \ref{item:sim-lab} of $\simRb(\lES, \lG, \tup{\lC, \lI}, \lM)$
  %%     and $e \in \lI$ follows that $\lG.\lLAB(e) = \lES.\lLAB(\lM(e))$
  %%   \item \ref{item:sim-cf} \\
      
  %%   \item \ref{item:sim-po-prfx} \\

  %%   \item \ref{item:sim-po} \\

  %%   \item \ref{item:sim-rf} \\
  %%     Since $e \in \lG.\lW$ there is no incoming $\lG.\lRF$ edges into $e$.
  %%     Thus the property follows trivially from the $\simRb(\lES, \lG, \tup{\lC, \lI}, \lM)$.

  %%   \item \ref{item:sim-mo} \\
  %%     As we did not modify $\lI$ on this step the property trivially follows
  %%     from the $\simRb(\lES, \lG, \tup{\lC, \lI}, \lM)$.

  %%   \item \ref{item:sim-vis} \\
      
      
  %%   \end{itemize}
    

    

  %% \end{itemize}


  
  
\end{proof}

%% \begin{proof}                   
  
  %% Note, that according to rules of traversal step relation (fig.~\ref{fig:traversal-rules})
  %% the traversal adds one covered or one issued event at one step.
  %% In order to build an updated event mappings $\lMC'$, $\lMI'$ 
  %% and event structure $\lES'$ 
  %% when traversing a new event $e$ in the configuration $\tup{\lC, \lI}$
  %% we will define simulation step relation 
  %% $\tup{\lMC, \lMI, \lES} \xrightarrow{\lG, \lC, \lI, e} \tup{\lMC', \lMI', \lES'}$.
  %% Simulation step relation is defined according to rules in fig.~\ref{fig:simrules}.
  %% Auxiliary relation 
  %% $(\lM, \lES_{base}) \xRightarrow{\lG, e} (\lM', \lES'_{base})$,
  %% called basic simulation step, 
  %% is used to update event mapping and some components of event structure
  %% (fig.~\ref{fig:simrules-base}).
  %% Our goal then is to prove that $\simR(\lES', \lG, \tup{\lC', \lI'})$ holds.
  %% Again, as the traversal adds one covered or one issued event at one step,
  %% we basically need to show that \ref{item:sim-lab}-\ref{item:sim-mo} hold
  %% for that added event.

  %% First, suppose that 
  %% $\lG \vdash \tup{\lC, \lI} \rightarrow \tup{\lC \uplus \{e\}, \lI}$ for some $e$.
  %% In this case we use basic construction step (fig.~\ref{fig:esstep-base})
  %% in order to build updated mapping $\lM'$ as well as
  %% updated components of event structure: $\lES', \lTID', \lLAB', \lMOD'$,
  %% and updated program order relation $\lPO'$.
  %% Giving that we already can prove
  %% \ref{item:sim-lab}, \ref{item:sim-cf} and \ref{item:sim-po}.

  %% \begin{itemize}
  %% \item \ref{item:sim-lab}
  %%   \begin{equation}
  %%     \begin{split}
  %%       & \forall{a \in (\lC \uplus \{e\}) \cup \lI} ~.~ \lG.\lLAB(a) = \lES.\lLAB(\lM(a)) \iff \\
  %%       & \forall{a \in \lC \cup \lI} ~.~ \lG.\lLAB(a) = \lES.\lLAB(\lM(a)) \wedge
  %%       \lG.\lLAB(e) = \lES.\lLAB(\lM(e))
  %%     \end{split}
  %%   \end{equation}
  %%   First conjunct follows from the $\simR(\lES, \lG, \tup{\lC, \lI}, \lM)$;
  %%   second conjunct follows from the definition of basic event structure construction step.

  %% \item \ref{item:sim-cf} \\
  %%   We need to show that
  %%   $\forall{a, b \in \lC \uplus \{e\}} ~.~ \tup{\lM'(a), \lM'(b)} \not\in \lES'.\lCF$.
  %%   Assume it is not true, that is
  %%   $\exists{a, b \in \lC \uplus \{e\}} ~.~ \tup{\lM'(a), \lM'(b)} \in \lES'.\lCF$.
  %%   Giving that $\simR(\lES, \lG, \tup{\lC, \lI}, \lM)$ holds,
  %%   we can conclude that $a = e \vee b = e$.
  %%   Let us say $a = e$ and $c = \lca(\lM'(e), \lM'(b))$.
  %%   From the definition of [BASIC-STEP] and 
  %%   $\tup{\lM'(c), \lM'(e)} \in \lES'.\lPO$ follows that $\tup{c, e} \in \lG.\lPO$.
  %%   From the definition of $\coverable$ we know that $\dom{\lG.\lPO;[e]} \subseteq \lC$;
  %%   giving that and $\tup{c, e} \in \lG.\lPO$ we can conclude that $c \in \lC$.
  %%   \note{Next, show that $\tup{c, b} \in \lG.\lPO$ and using the fact that
  %%     $\lG.\lPO$ is total order on events from same thread show a contradiction.
  %%     BTW We need additional condition for $\lPO$ in simulation relation.
  %%   }
    
    
    
  %% \end{itemize}
  
  %% \ref{item:sim-lab} follows trivially from the definition of basic construction step.
  %% \ref{item:sim-cf} 
  
  
  %% \ref{item:sim-lab} follow from the definition of the basic simulation step.
  %% In order to prove other properties of simulation relation,
  %% we have to consider different cases.
  

  %% \begin{itemize}
  %% \item
  %%   $e$ is a non-sc fence event, that is $e \in \lG.\lF^{\sqsubset\sco}$.
  %%   In this case we use [ADD-FENCE] rule in order to build $\lES'$ and $\lM'$.
  %%   \ref{item:sim-lab} follows from the definition of the basic simulation step.
  %%   \ref{item:sim-cf} 
    
  %%     \ref{item:sim-po} follows from the $\simR(\lES, \lG, \tup{\lC, \lI})$ 
  %%     and the definition of $\coverable$.
  %%     \ref{item:sim-ew} follows from the fact that
  %%     we did not modify the set of covered writes on this step.
  %%     As fences do not contribute neither to the $\lRF$ relation, neither to the $\lMO$, 
  %%     \ref{item:sim-rf}, and \ref{item:sim-mo} follows immediately.
  %%     Since $e$ is a fence event, $\hat{e}$ cannot have incoming $\lRF$ edges,
  %%     and thus for any conflicting write $\hat{w}$ that $\hat{e}$ depend on
  %%     the last edge in a $\lPO \cup \lRF$ dependency path is a $\lPO$ edge.
  %%     But since $\simR(\lES, \lG, \lC, \lI)$ holds we know that 
  %%     any $\lPO$-predcessor of $\hat{e}$ is visible, and thus $\hat{e}$ is also visible.
  %%     We have proven \ref{item:sim-vis}.

  %%   \item $e$ is a write event, that is $e \in \lG.\lW$.
  %%     \ref{item:sim-po} and \ref{item:sim-vis} can be proven similarly 
  %%     to the case when $e$ is a non-sc fence.
  %%     Since $e$ is a write, it cannot have any incoming $\lRF$ edges and thus
  %%     the \ref{item:sim-rf} follows directly from 
  %%     the fact that $\simR(\lES, \lG, \tup{\lC, \lI})$ holds.
  %%     \ref{item:sim-ew} and \ref{item:sim-mo} follow from the construction
  %%     of $\lEW'$ and $\lMO'$ in (COVER-WRITE) rule.
  
      %% To prove \ref{item:sim-rf-c} consider a read $r \in \lC$ that reads from $e$,
      %% that is $\tup{e, r} \in \lG.\lRF$.
      %% From the definition of $\coverable$ we know that $e \in I$,
      %% and thus $\tup{e, r} \in [\lI];\lG.\lRF;[\lC]$.
      %% Then from \ref{item:sim-rf-i} we can conclude that $\tup{\lMI(e), \lMC(r)} \in \lES.\lRF$.
      %% According to (COVER-WRITE) rule\footnote{\note{ask Anton how to make reference to rules}}
      %% $\tup{\hat{e}, \lMI(e)} \in \lEW'$
      %% and thus $\tup{\hat{e}, \lMC(r)} \in \lES'.\lJF$.
      
    %% \item $e$ is a read event, that is $e \in \lG.\lR$.
    %%   Again \ref{item:sim-po} can be proven similarly to the previous cases.
    %%   \ref{item:sim-ew} follows from the fact that
    %%   we did not modify the set of covered writes on this step.
    %%   \ref{item:sim-mo} holds because read events do not contribute to the $\lMO$.
    %%   From the definition of $\coverable$ we know that for write $w \in \lG.\lW$
    %%   that $e$ read from, that is $\tup{w, e} \in \lG.\lRF$, $w \in I$.
    %%   From that and the (COVER-READ) rule we can conclude that \ref{item:sim-rf} holds.
    %%   \note{further go my speculations}.
    %%   As for \ref{item:sim-vis} note that after we added $e$ into $\lC$,
    %%   new conflicting writes that $e$ depends on may appear.
    %%   Unlike the cases when $e$ is a write or a fence,
    %%   the last edge in a dependency path not necessary a $\lPO$ edge,
    %%   it might be an $\lRFE$ edge.
    %%   That is, we might have events $w, w'$, such that
    %%   $\tup{w, w'} \in (\lPO \cup \lRF)^+$,
    %%   $\tup{w', e} \in \lRFE$ and $\tup{w, e} \in \lCF$.
    %%   If $w$ not covered, that is $w \in \lI \setminus \lC$,
    %%   then we can conclude that $\tup{e, w} \in \lPO$ in execution graph,
    %%   that is the read $e$ reads from a write that depends on some promised write
    %%   from the same thread.
    %%   In order to support invariant \ref{item:sim-vis} we have to
    %%   cover all events up to $w$ at this step.
    %%   Alternatively we can give up on maintaining this property
    %%   and use Lemma \ref{lemma:2} instead.


%    \item $e \in \lG.\lF^{\sco} \wedge \dom{\lG.\lSC;[e]} \subseteq \lC$

  %%   \end{itemize}
%% \end{proof}

\begin{figure}[thb]

\begin{subfigure}{1\textwidth}

\small

    [BASIC-STEP]
    \begin{center}
    \AxiomC{$\hat{e} = max(\lE) + 1$}
    \noLine
    \UnaryInfC{$E' = \lE \cup \{\hat{e}\}$}
    \noLine
    \UnaryInfC{$\lM' = \lM[e \rightarrow \hat{e}]$}

    \AxiomC{$\lTID' = \lTID[\hat{e} \rightarrow \lG.\lTID(e)]$}
    \noLine
    \UnaryInfC{$\lLAB' = \lLAB[\hat{e} \rightarrow \lG.\lLAB(e)]$}
    \noLine
    \UnaryInfC{$\lMOD' = \lMOD[\hat{e} \rightarrow \lG.\lMOD(e)]$}

    \BinaryInfC{$
      \lG \vdash (\lM, \tup{\lE, \lTID, \lLAB, \lMOD})
      \ESbasicstep{e}
      (\lM', \tup{\lE', \lTID', \lLAB', \lMOD'})
    $}
    \DisplayProof
    \end{center}
    
\caption{Event structure basic construction step}
\label{fig:esstep-base}
\end{subfigure}

\begin{subfigure}{1\textwidth}
    
\small

    \begin{subfigure}{1\textwidth}
    [ADD-FENCE]
    \begin{center}

      \AxiomC{$e \in \lG.\lF^{\sqsubset\sco}$}
      \noLine
      \UnaryInfC{$
        \lG \vdash (\lM, \lES_{base})
        \ESbasicstep{e}
        (\lM', \lES'_{base})
      $}

      \AxiomC{$\lPO' = \lPO \cup \lM'(\lG.\lPO;[e])$}

      \BinaryInfC{$
        \lG \vdash \tup{\lM, \lES_{base}, \lPO, \lRMW, \lRF, \lEW, \lMO}
        \ESstep{e}
        \tup{\lM', \lES'_{base}, \lPO', \lRMW, \lRF, \lEW, \lMO}
        $}
      \DisplayProof
      
    \end{center}
    \label{fig:simrule-fence-cover}
    \end{subfigure}

    \begin{subfigure}{1\textwidth}
    [ADD-READ]
    \begin{center}
      
      \AxiomC{$e \in \lG.\lR$}
      \noLine
      \UnaryInfC{$
        \lG \vdash (\lM, \lES_{base})
        \ESbasicstep{e}
        (\lM', \lES'_{base})
      $}
      
      \AxiomC{$\lPO' = \lPO \cup \lM'(\lG.\lPO;[e])$}
      \noLine
      \UnaryInfC{$\lRF' = \lRF \cup \{\tup{\lM'(w), \lM'(e)} ~|~ \tup{w, e} \in \lG.\lRF \}$}
      
      \BinaryInfC{$
        \lG \vdash \tup{\lM, \lES_{base}, \lPO, \lRMW, \lRF, \lEW, \lMO}
        \ESstep{e}
        \tup{\lM', \lES'_{base}, \lPO', \lRMW, \lRF', \lEW, \lMO}
        $}
      \DisplayProof
      
    \end{center}
    \label{fig:esstep-read}
    \end{subfigure}

    \begin{subfigure}{1\textwidth}
    [ADD-WRITE]
    \begin{center}

      \AxiomC{$e \in \lG.\lW$}
      \noLine
      \UnaryInfC{$
        \lG \vdash (\lM, \lES_{base})
        \ESbasicstep{e}
        (\lM', \lES'_{base})
      $}
      
      \AxiomC{$\lPO' = \lPO \cup \lM'(\lG.\lPO;[e])$}
      \noLine
      \UnaryInfC{$\lMO' = \lMO \cup \lM'(\lG.\lMO;[e])$}
      \noLine
      \UnaryInfC{$\lEW' = \lEW \cup [\lM'(e)];[\lM(e)];\lEW^? \cup \lEW^?;[\lM(e)];[\lM'(e)]$}
      
      \BinaryInfC{$
        \lG \vdash \tup{\lM, \lES_{base}, \lPO, \lRMW, \lRF, \lEW, \lMO}
        \ESstep{e}
        \tup{\lM', \lES'_{base}, \lPO', \lRMW, \lRF, \lEW', \lMO'}
        $}
      \DisplayProof
      
    \end{center}
    \label{fig:esstep-write}
    \end{subfigure}
    
    \caption{Event structure construction step}
    \label{fig:esstep}
\end{subfigure}

\end{figure}


%% \begin{lemma}
%%   \label{lemma:2}
%%   Given an event structure $\lES$, an \imm execution graph $\lG$ 
%%   and its traversal configuration $\tup{\lC, \lI}$
%%   if the relation $\simR(\lES, \lG, \tup{\lC, \lI})$ holds
%%   then for any covered event $e \in \lC$ and any
%%   write from its masking set $w \in \lMASK(\lG, \hat{e})$
%%   there exist $\lES', \lC', \lI'$ such that
%%   $\lG \vdash \tup{\lC, \lI} \rightarrow^* \tup{\lC', \lI'}$, 
%%   $\simR(\lES', \lG, \tup{\lC', \lI'})$
%%   and $\tup{w, \hat{e}} \in \lES'.\lEW;\lES'.\lPO^=$.
%%   \note{Probably, $\lI = \lI'$ ?}
%% \end{lemma}

%% \begin{lemma}
%%   \label{lemma:3}
%%   Given an event structure $\lES$, an \imm execution graph $\lG$ 
%%   and its traversal configuration $\tup{\lC, \lI}$
%%   if the relation $\simR(\lES, \lG, \tup{\lC, \lI})$ holds
%%   then there exists $\lES', \lC', \lI'$ and event structure execution $\lX$ such that
%%   $\lG \vdash \tup{\lC, \lI} \rightarrow^* \tup{\lC', \lI'}$
%%   and $\lX$ satisfies the following conditions.
%%   \begin{itemize}
%%   \item $\lX.\lE = \lMC(C')$
%%   \item $\lX.\lPO = \lMC([\lC'];\lG.\lPO;[\lC'])$
%%   \item $\lX.\lRMW = \lMC([\lC'];\lG.\lRMW;[\lC'])$
%%   \item $\lX.\lRF = \lMC([\lC'];\lG.\lRF;[\lC'])$
%%   \item $\lX.\lMO = \lMC([\lC'];\lG.\lMO;[\lC'])$    
%%   \end{itemize}
%% \end{lemma}

\setmonofont[Mapping=tex-text]{CMU Typewriter Text}
\bibliographystyle{acm}
\bibliography{main.bib}

\end{document}
