\documentclass[12pt]{article}
\usepackage{fontspec}
\usepackage{xcolor}
\usepackage{listings}
\usepackage[justification=centering]{caption}
\usepackage{subcaption}
\usepackage{cite}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{bussproofs}
\usepackage{tikz}
\usepackage{float}
\usepackage{graphicx}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{array}
\usepackage{stmaryrd}
\usepackage{pifont}
\usepackage{enumitem}

\input{defs.tex}

\begin{document}

\begin{center}
{\center \LARGE Compiling Event Structures to the Intermediate Memory Model }
\end{center}

\section{Event Structure Model}

\begin{definition}
  An \emph{event structure} $\lES$ is a tuple
  $\tup{\lE, \lEi, \lTID, \lLAB, \lMOD, \lPO, \lRMW, \lRF, \lEW, \lMO}$ where:
  \begin{itemize}
  \item $\lE \subseteq \N$ --- finite set of events. 
  \item $\lEi \subseteq \lE$ --- initialization events.
  \item $\lTID \defeq \fun{\lE}{\Tid}$ --- function that assigns a thread id to every event.
    Given thread id $i \in \Tid$ we will denote by $\lE_i$ the set of all events belonging 
    to $i^{th}$ thread, that is $\lE_i \defeq \{e \in \lE ~|~ \lTID(e) = i\}$.
    We assume that if $e \in \lEi$ then $\lTID(e) = 0$.
  \item $\lLAB \defeq \fun{\lE}{\Lab}$ --- function that assigns a label to every event.
    Labels are of one of the following forms:
    \begin{itemize}
    \item $\rlab{x}{v}^s$ --- a read, where $x \in \Loc$, $v \in \Val$ 
      and $s \in \Bool$ is an exclusive flag 
      (we will denote exclusive reads as $\rlabEx{x}{v}$);
    \item $\wlab{x}{v}$ --- a write, where $x \in \Loc$, $v \in \Val$;
    \item $\flab$ --- a fence.
    \end{itemize}
    $\lLAB$ induces the following functions:
    \begin{itemize}
    \item $\lTYP \defeq \fun{\lE}{\{\lR, \lW, \lF\}}$ --- assigns a type to every event;
    \item $\lLOC \defeq \pfun{\lE}{Loc}$ --- returns the location of event (when applicable);
    \item $\lVALR \defeq \pfun{\lE}{Val}$ --- returns the read value of event (when applicable);
    \item $\lVALW \defeq \pfun{\lE}{Val}$ --- returns the written value of event (when applicable).
    \end{itemize}
    We assume that $\forall{e} \in \lEi. \; \lLAB(e) = \wlab{x}{0}$.
  \item A function $\lMOD = G.\lE \rightarrow \Mod$ is a memory order assignment.
    Elements of the set $\Mod \defeq \{ \rlx, \rel, \acq, \acqrel, \sco \}$ are
    called \emph{memory order} parameters.
    Additionally, $\lMOD$ satisfies the following constraints:
    \begin{itemize}
    \item $e \in \lR \Rightarrow \lMOD(e) \in \{ \rlx, \acq, \sco \}$,
    \item $e \in \lW \Rightarrow \lMOD(e) \in \{ \rlx, \rel, \sco \}$,
    \item $e \in \lF \Rightarrow \lMOD(e) \in \{ \rlx, \acqrel, \sco \}$.
    \end{itemize}
  \item $\lPO \subseteq \lE \times \lE$ --- \emph{program order}, which is a strict partial order.
    It orders all initialization events before all other events,
    that is $\lEi \times (\lE \setminus \lEi) \subseteq \lPO$.
    Moreover, $\lPO$ induces the \emph{conflict relation} $\lCF$.
    \begin{itemize}
      \item  $\lCF \defeq \lPO^{-1};[E];\lPO \setminus \lPO^{=}$.
    \end{itemize}
  \item $\lRMW \subseteq \lR;(\lPO_{imm} \cap =_{loc});\lW \times \lE$ ---
    \emph{read-modify-write pairs}.
  \item $\lRF \subseteq \lW; =_{loc}; \lR$ --- \emph{reads-from} relation, which the following
    hold for:
    \begin{itemize}
    \item $\forall{\tup{a, b}} \in \lRF. \; \lVALW(a) = \lVALR(b)$;
    \item $\forall{a_1, a_2, b}. \; \tup{a_1, b} \in \lRF \wedge \tup{a_2, b} \in \lRF \Rightarrow a_1 = a_2.$
    \end{itemize}
  \item $\lEW \subseteq \lW \times \lW$ --- is the \emph{equal write} relation, 
    which is an irreflexive, symmetric and transitive relation between conflicting writes on the
    same location writing same values 
    (that is $\lEW(e_1, e_2) \Rightarrow \lVALW(e_1) = \lVALW(e_2)$).
    Given $\lRF$, $\lEW$ and $\lCF$ we will also define a derived \emph{justified from} relation:
    \begin{itemize}
      \item $\lJF \defeq \lEW^?;\lRF \setminus \lCF$
    \end{itemize}
  \item $\lMO \subseteq \lW \times \lW$ --- \emph{modification order}, which is a strict partial order.
  \end{itemize}
\end{definition}

\begin{definition}
  Using the primitive relations of an event structure $\lES$ we define following derived relations:
  \begin{itemize}
    \item $\lES.\lRB \defeq (\lES.\lJF^{-1};\lES.\lMO) \setminus \lES.\lCF^?$ --- 
      \emph{reads before};
    \item $\lES.\lECO \defeq (\lES.\lJF \cup \lES.\lRB \cup \lES.\lMO)^+$ --- 
      \emph{extended coherence order}
  \end{itemize}
\end{definition}

\begin{definition}
  Giving an event structure $\lES$ we define the \emph{happens-before} relation $\lHB$
  using auxililarly relations: 
  $\lRSEQ$ --- release sequence,
  $\lRELP$ --- release prefix and
  $\lSW$ --- synchronize-with.
  \begin{itemize}
  \item $\lRSEQ \defeq [\lWsqeq{rlx}];(\lmakeLoc{\lPO};[\lWsqeq{rlx}] \cup 
    (\lmakeLoc{\lPO^?};[\lWsqeq{\rlx}];\lJF;\lRMW)^*)$;
  \item $\lRELP \defeq [\lEsqeq{rel}];([\lW] \cup [\lF];\lPO);\lRSEQ$
  \item $\lSW \defeq \lRELP; (\lRFI \cup \lmakeLoc{\lPO^?};\lRFE); [\lR \cup \lPO;[\lF]);[\lEsqeq{\acq}]$
  \item $\lHB \defeq (\lPO \cup \lSW)^+$
  \end{itemize}
\end{definition}

\begin{definition}
  For an event structure $\lES$ the set of its visible events $\lVIS(\lES)$ defined as follow:
  \begin{itemize}
    \item $\lVIS(\lES) \defeq 
      \{ e \in \lES ~|~ \lES.\lW;(\lES.\lCF \cap (\lES.\lPO \cup \lES.\lRF)^+);[e] \subseteq 
         \lES.\lEW;\lES.\lPO^=
      \}$
  \end{itemize}
\end{definition}

\begin{definition}
  Given an event structure $\lES$ we will a call a tuple $\tup{\lE, \lPO, \lRMW, \lRF, \lMO}$ 
  its \emph{execution} $\lX$ if the following conditions hold:
  \begin{itemize}
    \item $\lX.\lE \subseteq \lVIS(\lES)$
    \item $[\lX.\lE];\lES.\lCF;[\lX.\lE] = \emptyset$
    \item $\lES.\lPO;[\lX.\lE] \subseteq \lX.\lE \times \lX.\lE$
    \item $\forall{\tup{e, e'}} \in (\lX.\lE;\lES.\lPO;[\lES.\lE \setminus \lX.\lE]) ~.~ 
      \exists{e''} \in \lX.\lE ~.~ \tup{e', e''} \in \lES.\lCF$
    \item $\lX.\lPO = \lES.\lPO \cap \lX.\lE \times \lX.\lE$
    \item $\lX.\lRMW = \lES.\lRMW \cap \lX.\lE \times \lX.\lE$
    \item $\lX.\lRF = \lES.\lJF \cap \lX.\lE \times \lX.\lE$
    \item $\lX.\lMO = \lES.\lMO \cap \lX.\lE \times \lX.\lE$
  \end{itemize}
\end{definition}

\begin{definition}
  A function $O_{\lX} :: \fun{\Loc}{\Val}$ is an \emph{outcome} 
  of an event structure's $\lES$ execution $\lX$
  if for every $x \in \Loc$ either $O_{\lX}(x) = \lES.\lVALW(w)$ 
  for some $\lX.\lMO$-maximal write event $w$, 
  or $O_{\lG} = 0$ and $\lX.\lW_x = \emptyset$.
\end{definition}

\section{Intermediate Memory Model}

\begin{definition}
  An \imm execution graph $\lG$ is a tuple \\
  $\tup{\lE, \lLAB, \lMOD, \lRMW, \lRF, \lMO, \lDATA, \lADDR, \lCTRL, \lCASDEP}$ where:
  \begin{itemize}
    \item $\lE$ is a set of events. 
      Events in \imm have different representation comparing to the event structure model. 
      That is, an event is either:
      \begin{itemize}
        \item an \emph{initialization} event $\tup{\lINIT~x}$ where $x \in \Loc$;
        \item a \emph{non-initialization} event $\tup{i, n}$ where $i \in \Tid$ and $n \in \Q$.
      \end{itemize}
      Given this representation one could restore some piece of the event structure notation, 
      in particular:
      \begin{itemize}
        \item $\lEi \defeq \{e \in E ~|~ \exists{x} \in \Loc ~.~ e = \tup{\lINIT~x}\}$;
        \item $\lTID :: \fun{\lE}{\Tid}$ s.t. \\
          $\forall{e} ~.~ (e = \tup{\lINIT~x} \implies \lTID(e) = 0) \wedge 
           (e = \tup{i, n} \Rightarrow \lTID(e) = i)$;
        \item $\lPO \subseteq \lE \times \lE$ s.t. \\
          $\tup{e_1, e_2} \in \lPO \iff (e_1 \in \lEi \wedge e_2 \not\in \lEi) \vee 
           (e_1 \not\in \lEi \wedge e_2 \not\in \lEi \wedge \lTID(e_1) = \lTID(e_2) \wedge
            \lSN(e_1) < \lSN(e_2))$, 
          where $\lSN(\tup{i, n}) = n$.
      \end{itemize}
      \item $\lLAB, \lMOD, \lRMW, \lRF, \lMO$ have the same definitions
        as in the event structure model.
      \item $\lDATA \subseteq \lR \times \lW$ --- data dependency;
      \item $\lADDR \subseteq \lR \times (\lR \cup \lW)$ --- address dependency;
      \item $\lCTRL \supseteq \lCTRL; \lPO$ --- control dependency;
      \item $\lCASDEP \subseteq [R];\lPO;[R^{\Ex}]$ --- CAS dependency;
  \end{itemize}
\end{definition}

\begin{definition}
  A function $O_{\lG} :: \fun{\Loc}{\Val}$ is an \emph{outcome} of an \imm execution graph $\lG$
  if for every $x \in \Loc$ either $O_{\lG}(x) = \lG.\lVALW(w)$ 
  for some $\lG.\lMO$-maximal write event $w$, 
  or $O_{\lG} = 0$ and $\lG.\lW_x = \emptyset$.
\end{definition}

\section{Compilation correctness}

\begin{theorem}
  For every consistent \imm execution graph $G$
  there exists a consistent event structure $\lES$ and its consistent execution $\lX$
  such that an outcome of execution graph $O_{\lG}$ matches
  an outcome of events structure's execution $O_{\lX}$, 
  that is $O_{\lG} = O_{\lX}$.
\end{theorem}

\subsection{Traversal}

\begin{definition}
  A traversal configuration of an execution graph $\lG$ is a pair $\tup{\lC, \lI}$, 
  where $\lC \subseteq \lG.\lE$ is a set of \emph{covered} events 
  and $\lI \subseteq \lG.\lW$ is a set of \emph{issued} events,
  that additionally satisfies the following properties:
  \begin{itemize}
    \item $\lG.\lEi \subseteq \lC$;
    \item $\lC \cap \lG.\lW \subseteq \lI$;
    \item $\lC \subseteq \lCOVERABLE(\lG, \lC, \lI)$;
    \item $\lI \subseteq \lISSUABLE(\lG, \lC, \lI)$;
  \end{itemize}
  Configuration is called \emph{initial} when $\lC = \lI = \lG.\lEi$.
\end{definition}

\begin{definition}
  A write event $w \in \lG.\lW$ is \emph{issuable} in $\lG$ and $\tup{\lC, \lI}$,
  denoted $w \in \lISSUABLE(\lG, \lC, \lI)$, 
  if the following conditions are met:
  \begin{itemize}
    \item $\dom{([\lG.\lW^{rel}];\lmakeLoc{\lG.\lPO} \cup [\lG.\lF];\lG.\lPO);[w]} \subseteq \lC$
    \item $\dom{(\lG.\lDETOUR \cup \lG.\lRFE);\lG.\lPPO;[w]} \subseteq \lI$
    \item $\dom{(\lG.\lDETOUR \cup \lG.\lRFE);[\lG.R^{acq}];\lG.\lPO;[w]} \subseteq \lI$
  \end{itemize}
\end{definition}

\begin{definition}
  An event $e \in \lG.\lE$ is \emph{coverable} in $\lG$ and $\tup{\lC, \lI}$,
  denoted $e \in \lCOVERABLE(\lG, \lC, \lI)$, 
  if $\dom{\lG.\lPO;[e]} \subseteq \lC$ and either:
  \begin{itemize}
    \item $e \in \lG.\lW \cap \lI$
    \item $e \in \lG.\lR \wedge \dom{\lG.\lRF;[e]} \subseteq I$
    \item $e \in \lG.\lF^{\sqsubset\sco}$
    \item $e \in \lG.\lF^{\sco} \wedge \dom{\lG.\lSC;[e]} \subseteq \lC$
  \end{itemize}
\end{definition}

\begin{figure}[thb]

\small
    
    \begin{center}
    \AxiomC{$e \in \lCOVERABLE(\lG, \lC, \lI)$}
    \UnaryInfC{$
      \lG \vdash \tup{\lC, \lI} \rightarrow \tup{\lC \uplus \{e\}, \lI}
    $}
    \DisplayProof
    % 
    \rulehskip
    % 
    \AxiomC{$w \in \lISSUABLE(\lG, \lC, \lI)$}
    \UnaryInfC{$
      \lG \vdash \tup{\lC, \lI} \rightarrow \tup{\lC, \lI \uplus \{w\}}
    $}
    \DisplayProof
    \end{center}
    
    \caption{Traversal step relation}
    \label{fig:traversal-rules}
\end{figure}

\subsection{Simulation relation}

\begin{definition}
  Simulation relation $\lSIM(\lES, \lG, \tup{\lC, \lI})$ that binds an 
  event structure $\lES$, an \imm execution graph $\lG$ and 
  a traversal configuration $\tup{\lC, \lI}$,
  holds if there exists a injecive mapping between events $\lM :: \fun{\lG.\lE}{\lES.\lE}$
  and a program counter $\lPC :: \fun{\Tid}{\lES.\lE}$
  such that the following conditions are met:
  \begin{enumerate}[label=\textbf{S.\arabic*}]
    \item \label{item:sim-lab} 
      $\forall{e \in \lC \cup \lI} ~.~ \lG.\lLAB(e) = \lES.\lLAB(\lM(e))$;
    \item \label{item:sim-} 
      $\forall{i \in \Tid} ~.~ \lDOM(\lES.\lPO^?;[\lPC(i)]) = \lM(\lC) \cap \lES.\lE_i$;
    \item \label{item:sim-vis} 
      $\forall{e \in \lC \cup \lI} ~.~ \lM(e) \in \lVIS(\lES)$;
    \item \label{item:sim-rf} 
      $\forall{\tup{w, r} \in \lG.\lRF;[\lC] ~.~ \tup{\lM(w), \lM(r)} \in \lES.\lJF}$;
    \item \label{item:sim-mo}
      $\forall{\tup{w, w'} \in [\lI];\lG.\lMO;[\lI] ~.~ \tup{\lM(w), \lM(w')} \in \lES.\lMO}$;
  \end{enumerate}
\end{definition}

\begin{lemma}
  Given an event structure $\lES$, an \imm execution graph $\lG$ 
  and its traversal configuration $\tup{\lC, \lI}$
  if the relation $\lSIM(\lES, \lG, \tup{\lC, \lI})$ holds and 
  there exists $\tup{\lC', \lI'}$ s.t. $\lG \vdash \tup{\lC, \lI} \rightarrow \tup{\lC', \lI'}$
  then there exists $\lES'$ s.t. $\lSIM(\lES', \lG, \tup{\lC', \lI'})$ 
\end{lemma}

\begin{proof}
  We will define simulation step relation 
  $\tup{\lM, \lPC, \lES} \xrightarrow{\lG, \lC, \lI, e} \tup{\lM', \lPC', \lES'}$
  in order to build an updated event mapping $\lM'$, program counter $\lPC'$ 
  and event structure $\lES'$ 
  when traversing a new event $e$ in the configuration $\tup{\lC, \lI}$.
  Simulation step relation is defined accordint to rules in fig.~\ref{fig:simrules}.
  Auxiliary relation 
  $\tup{\lM, \lPC, \lES_{base}} \xRightarrow{\lG, \lC, \lI, e} \tup{\lM', \lPC', \lES'_{base}}$,
  called basic simulation step, 
  is used to update event mapping, program counter and some components of event structure
  (fig.~\ref{fig:simrules-base}).

  First, suppose that 
  $\lG \vdash \tup{\lC, \lI} \rightarrow \tup{\lC \uplus \{e\}, \lI}$ for some $e$.
  We then have to consider the following cases.
  \begin{itemize}
    \item $e \in \lG.\lW$. 

    \item $e \in \lG.\lR \wedge \dom{\lG.\lRF;[e]} \subseteq I$
    \item $e \in \lG.\lF^{\sqsubset\sco}$
    \item $e \in \lG.\lF^{\sco} \wedge \dom{\lG.\lSC;[e]} \subseteq \lC$
  \end{itemize}
\end{proof}

\begin{figure}[thb]

\small

    \begin{center}
    \AxiomC{$\hat{e} = max(\lE) + 1$}
    \noLine
    \UnaryInfC{$\lM' = \lM[e \rightarrow \hat{e}]$}
    \noLine
    \UnaryInfC{$\lPC' = \lPC[\lG.\lTID(e) \rightarrow \hat{e}]$}
    \noLine
    \UnaryInfC{$E' = \lE \cup \{\hat{e}\}$}

    \AxiomC{$\lTID' = \lTID[\hat{e} \rightarrow \lG.\lTID(e)]$}
    \noLine
    \UnaryInfC{$\lLAB' = \lLAB[\hat{e} \rightarrow \lG.\lLAB(e)]$}
    \noLine
    \UnaryInfC{$\lMOD' = \lMOD[\hat{e} \rightarrow \lG.\lMOD(e)]$}

    \AxiomC{$\lPO' = \lPO \cup \lE_i \times \{\hat{e}\}$}

    \TrinaryInfC{$
      \tup{\lM, \lPC, \lE, \lTID, \lLAB, \lMOD, \lPO, \lRMW}
      \xRightarrow{\lG, \lC, \lI, e}
      \tup{\lM', \lPC', \lE', \lTID', \lLAB', \lMOD', \lPO', \lRMW}
    $}
    \DisplayProof
    \end{center}
    
\caption{Basic simulation step}
\label{fig:simrules-base}
\end{figure}

\begin{figure}
    
\small

    \begin{subfigure}{1\textwidth}
    [COVER-WRITE]
    \begin{center}
    \AxiomC{$
      \tup{\lM, \lPC, \lES_{base}}
      \xRightarrow{\lG, \lC, \lI, e}
      \tup{\lM', \lPC', \lES'_{base}}
    $}

    \AxiomC{$e \in \lG.\lW$}
    \noLine
    \UnaryInfC{$\lMO' = \lMO \cup \lM(\lG.\lMO) \cap E' \times E'$}
    \BinaryInfC{$
      \tup{\lM, \lPC, \lES_{base}, \lRF, \lEW, \lMO}
      \xrightarrow{\lG, \lC, \lI, e}
      \tup{\lM', \lPC', \lES_{base}, \lRF, \lEW, \lMO'}
    $}
    \DisplayProof
    \end{center}
    \label{fig:simrule-write-cover}
    \end{subfigure}
    
    \caption{Simulation step}
    \label{fig:simrules}
\end{figure}

\setmonofont[Mapping=tex-text]{CMU Typewriter Text}
\bibliographystyle{acm}
\bibliography{main.bib}

\end{document}
