\documentclass[12pt]{article}
\usepackage{fontspec}
\usepackage{xcolor}
\usepackage{listings}
\usepackage[justification=centering]{caption}
\usepackage{subcaption}
\usepackage{cite}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{bussproofs}
\usepackage{tikz}
\usepackage{float}
\usepackage{graphicx}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{array}
\usepackage{stmaryrd}
\usepackage{pifont}
\usepackage{enumitem}
\usepackage{extarrows}

\usepackage{hyperref}
\usepackage[capitalise]{cleveref}
%% \usepackage{chngcntr}

\input{defs.tex}

\begin{document}

\begin{center}
{\center \LARGE Compiling Event Structures to the Intermediate Memory Model }
\end{center}

\section{Executions}

\begin{definition}
  \label{def:exec}
  
  An execution graph $X$ is a tuple $\tup{\lE, \lLAB, \lRF, \lMO}$ where:
  \begin{itemize}

    \item $\lE$ is a set of events. 
    An event is either:
    \begin{itemize}
      \item an \emph{initialization} event $\tup{\lINIT~x}$ where $x \in \Loc$;
      \item a \emph{non-initialization} event $\tup{i, n}$ where $i \in \Tid$ and $n \in \Q$.
    \end{itemize}
    Given this representation one could derive the following notions:
    \begin{itemize}

      \item $\lEo \defeq \{e \in E ~|~ \exists{x} \in \Loc ~.~ e = \tup{\lINIT~x}\}$ ---
      a set of \emph{initialization events};

      \item $\lTID : \lX \fun \Tid$ ---
      a function, that assigns a \emph{thread identifier} to every event, s.t. \\
      \begin{equation*}
        \begin{split}
          \forall{e} ~.~
          & (\exists{x \in \Loc} ~.~ e = \tup{\lINIT~x} \Rightarrow \lTID(e) = 0) \wedge \\ \wedge
          & (\exists{i \in \Tid, n \in \N} ~.~ e = \tup{i, n} \Rightarrow \lTID(e) = i)
        \end{split}
      \end{equation*}
      
      \item $\lPO \subseteq \lE \times \lE$ a \emph{program order} relation s.t. \\
      \begin{equation*}
        \begin{split}
          & \tup{e_1, e_2} \in \lPO \Leftrightarrow \\
          & \Leftrightarrow (e_1 \in \lEo \wedge e_2 \not\in \lEo) \vee 
          (e_1, e_2 \not\in \lEo \wedge \lTID(e_1) = \lTID(e_2) \wedge
          \lSN(e_1) < \lSN(e_2))
        \end{split}
      \end{equation*}
      where $\lSN(\tup{i, n}) = n$.

      Note that $\lPO$ totally orders all events within a thread.
    \end{itemize}

    \item $\lLAB \defeq \lE \fun \Lab$ --- function that assigns a label to every event.
    Labels are of one of the following forms:
    \begin{itemize}
      \item $\rlabExExpl{o}{x}{v}{\mathtt{f}}$ --- a read, where
        $x \in \Loc$, $v \in \Val$, $o \in \Mod$ 
        and $\mathtt{f} \in \{\Ex, \NotEx\}$ is an exclusive flag 
        (we will denote exclusive reads as $\rlabEx{o}{x}{v}$,
        for non-exclusive reads we will omit the flag);
      \item $\wlab{o}{x}{v}$ --- a write, where $x \in \Loc$, $v \in \Val$, $o \in \Mod$;
      \item $\flab{o}$ --- a fence, where $o \in Mod$.
    \end{itemize}
    We assume that $\forall{e} \in \lEo. \; \lLAB(e) = \wlab{\rlx}{x}{0}$.
    $\lLAB$ induces the following functions:
    \begin{itemize}
      \item $\lTYP \defeq \lE \fun \{\lR, \lW, \lF\}$ --- assigns a type to every event;
      \item $\lLOC \defeq \lE \pfun \Loc $ --- returns the location of event (when applicable);
      \item $\lVALR \defeq \lE \pfun \Val$ --- returns the read value of event (when applicable);
      \item $\lVALW \defeq \lE \pfun \Val$ --- returns the written value of event
        (when applicable);
      \item $\lMOD = G.\lE \rightarrow \Mod$ --- returns the associated memory order parameter.
        Additionally, $\lMOD$ satisfies the following constraints:
        \begin{itemize}
        \item $e \in \lR \Rightarrow \lMOD(e) \in \{ \rlx, \acq, \sco \}$;
        \item $e \in \lW \Rightarrow \lMOD(e) \in \{ \rlx, \rel, \sco \}$;
        \item $e \in \lF \Rightarrow \lMOD(e) \in \{ \rlx, \acqrel, \sco \}$.
        \end{itemize}
    \end{itemize}

    Pairs of events, consisting of an exclusive read followed by exclusive write in $\lPO_{imm}$,
    that operate on the same location,
    form a \emph{read-modify-write} relation:
    \begin{itemize}
      \item $\lRMW \defeq [\lR_{\Ex}];(\lPO_{imm} \cap =_{\lLOC});[\lW_{\Ex}]$.
    \end{itemize}

    \item $\lRF \subseteq [\lW];=_{\lLOC};[\lR]$ --- \emph{reads-from} relation,
    which the following hold for:
    \begin{itemize}
      \item $\forall{\tup{a, b}} \in \lRF. \; \lVALW(a) = \lVALR(b)$;
      \item $\forall{a_1, a_2, b}. \;
        \tup{a_1, b} \in \lRF \wedge \tup{a_2, b} \in \lRF \Rightarrow a_1 = a_2.$
    \end{itemize}
    
    \item $\lMO \subseteq \lW \times \lW$ --- \emph{modification order},
    which is a strict partial order among write operations.

  \end{itemize}

  Using the definition of relations given above,
  we will also derive the following relations:
  \begin{itemize}
    \item $\lRB \defeq (\lRF^{-1};\lMO)$ --- \emph{reads before};
    \item $\lECO \defeq (\lRF \cup \lRB \cup \lMO)^+$ --- \emph{extended coherence order}.
  \end{itemize}

\end{definition}


\begin{definition}
  Giving an execution $X$ we define the \emph{happens-before} relation $\lHB$
  using auxililarly relations: 
  $\lRSEQ$ --- release sequence,
  $\lRELP$ --- release prefix and
  $\lSW$ --- synchronize-with.
  \begin{itemize}
  \item $\lRSEQ \defeq [\lWsqeq{rlx}];(\lmakeLoc{\lPO};[\lWsqeq{rlx}] \cup 
    (\lmakeLoc{\lPO^?};[\lWsqeq{\rlx}];\lRF;\lRMW)^*)$;
  \item $\lRELP \defeq [\lEsqeq{rel}];([\lW] \cup [\lF];\lPO);\lRSEQ$;
  \item $\lSW \defeq \lRELP; (\lRFI \cup \lmakeLoc{\lPO^?};\lRFE); ([\lR] \cup \lPO;[\lF]);[\lEsqeq{\acq}]$;
  \item $\lHB \defeq (\lPO \cup \lSW)^+$.
  \end{itemize}
\end{definition}

\begin{definition}
  We will call an execution graph $X$ \emph{consistent} if the following properties hold:
  \begin{itemize}
    \item $X.\lMO^= = [X.\lW];=_{\lLOC};[X.\lW]$
    \item $X.\lRMW \cap (X.\lRB;X.\lMO) = \emptyset$
    \item $X.\lHB;X.\lECO^?$ is irreflexive.
  \end{itemize}
\end{definition}

\begin{definition}
  A function $O : \Loc \fun \Val$ is an \emph{outcome} 
  of a consistent execution graph $X$
  if for every $x \in \Loc$ either $O(x) = X.\lVALW(w)$ 
  for some $X.\lMO$-maximal write event $w$, 
  or $O(x) = 0$ and $X.\lW_x = \emptyset$.
\end{definition}

\section{Intermediate Memory Model}

\begin{definition}
  An \imm execution graph $G$ is a tuple \\
  $\tup{X, \lDATA, \lADDR, \lCTRL, \lCASDEP}$ where:
  \begin{itemize}
    \item $X$ is a regular execution graph (from the definition \ref{def:exec}).
      We will omit the $X$ when refering to its components in the context of $G$
      (e.g. we will write $G.\lPO$ instead of $G.X.\lPO$).
    \item $\lDATA \subseteq \lR \times \lW$ --- data dependency.
    \item $\lADDR \subseteq \lR \times (\lR \cup \lW)$ --- address dependency.
    \item $\lCTRL \supseteq \lCTRL; \lPO$ --- control dependency.
    \item $\lCASDEP \subseteq [R];\lPO;[R^{\Ex}]$ --- CAS dependency.
  \end{itemize}

  We will also need several derived relations:
  \begin{itemize}
    \item $\lBOB \defeq
      \lPO;[\lW^{\rel}] \cup [R^{\acq}];\lPO \cup \lPO;[\lF] \cup [\lF];\lPO \cup [\lW^{\rel}];\lPO_{\lLOC};[\lW]$;
    \item $\lDEPS \defeq \lDATA \cup \lCTRL \cup \lADDR;\lPO^? \cup \lCASDEP \cup [\lR_{\Ex}];\lPO$;
    \item $\lPPO \defeq [\lR];(\lDEPS \cup \lRFI)^+;[\lW]$;
    \item $\lDETOUR \defeq (\lMOE;\lRFE) \cap \lPO$.
  \end{itemize}

\end{definition}

\begin{definition}
  An \imm execution graph $G$ is called \emph{\imm-consistent} if the following properties hold:
  \begin{itemize}
    \item $G.X$ is a consistent execution;
    \item $G.\lRFE \cup G.\lBOB \cup G.\lPPO \cup G.\lDETOUR$ is acyclic.
  \end{itemize}
\end{definition}

\section{Event Structure Model}

\begin{definition}
  \label{def:es}
  
  An \emph{event structure} $S$ is a tuple
  $\tup{\lEs, \lJF, \lEW, \lMO}$ where:
  \begin{itemize}
    \item $\lEs$ is a set of \emph{s-events}.
    An s-event $\hat{e} \in \lEs$ is a tuple $\tup{i, \Path}$
    where $i \in \Tid$ and $\Path = (l_1, \dots, l_n)$ is a finite non-empty sequence of labels.
    We will also distinguish a set of initialization s-events $\lEo$.
    For these events thread identifier is equal to 0 and
    sequence of labels consists of single label, which is a relaxed write:
    \begin{equation*}
      \forall{\hat{e} \in \lEo} ~.~ \exists{x \in \Loc} ~.~ \hat{e} = \tup{0, \wlab{\rlx}{x}{0}}
    \end{equation*}
    Giving $\lEs$ we will also derive the following definitions:

    \begin{itemize}
      
      \item $\lTID : \lE \fun \Tid$ --- function that assigns a thread id to every s-event.
      \begin{equation*}
        \lTID(\tup{i, \Path}) \defeq i
      \end{equation*}
      Given thread id $i \in \Tid$ we will denote by $\lEi{i}$ the set of all events belonging 
      to $i^{th}$ thread, that is $\lEi{i} \defeq \{e \in \lE ~|~ \lTID(e) = i\}$.
      We will also distinguish a set of initialization events $\lEo$.
      For these events thread identifier is equal to 0 and
      sequence of labels consists of single label, which is a relaxed write:
      \begin{equation*}
        \forall{\hat{e} \in \lEo} ~.~ \exists{x \in \Loc} ~.~ \hat{e} = \tup{0, \wlab{\rlx}{x}{0}}
      \end{equation*}

      \item $\lLAB \defeq \lE \fun \Lab$ --- function that assigns a label to every s-event,
      defined as follow:
      \begin{equation*}
        \lLAB(\tup{i, (l_1, \dots, l_n)}) \defeq l_n
      \end{equation*}
      This function iduces $\lTYP$, $\lLOC$, $\lVALR$, $\lVALW$ and $\lMOD$
      as in the definition \ref{def:exec} of execution graph.

      \item Program order defined as follows:
      \begin{equation*}
        \begin{split}
        & \tup{\hat{e_1}, \hat{e_2}} \in \lPO \Leftrightarrow \\
        &   \Leftrightarrow (\hat{e_1} \in \lEso \wedge \hat{e_2} \not\in \lEso) \vee (\Path(\hat{e_1}) \prec \Path(\hat{e_2}))
        \end{split}
      \end{equation*}
      where $\prec$ is a lexicographical order.

      \item $\lCF \subseteq [\lE];=_{\lTID};[\lE]$ --- \emph{conflict relation},
      which binds two events whenever they are issued from the same thread but
      in different execution branches.
      More formally:
      \begin{equation*}
        % \tup{\hat{e_1}, \hat{e_2}} \in \lCF \Leftrightarrow
      \end{equation*}

      \item $\lRMW \subseteq [\lR_{\Ex}];(\lPO_{imm} \cap =_{\lLOC});[\lW_{\Ex}]$ ---
      \emph{read-modify-write pairs}.

    \end{itemize}
     

    \item $\lJF \subseteq [\lW];=_{\lLOC};[\lR]$ --- \emph{justified-from} relation,
    which the following
    hold for:
    \begin{itemize}
    \item $\forall{\tup{a, b}} \in \lJF. \; \lVALW(a) = \lVALR(b)$;
    \item $\forall{a_1, a_2, b}. \;
      \tup{a_1, b} \in \lJF \wedge \tup{a_2, b} \in \lJF \Rightarrow a_1 = a_2.$
    \end{itemize}
    
  \item $\lEW \subseteq \lW \times \lW$ --- is the \emph{equal write} relation, 
    which is an irreflexive, symmetric and transitive relation between conflicting writes on the
    same location writing same values 
    (that is $\lEW(e_1, e_2) \Rightarrow \lVALW(e_1) = \lVALW(e_2)$).
    Given $\lJF$, $\lEW$ and $\lCF$ we will also define a derived \emph{read from} relation:
    \begin{itemize}
      \item $\lRF \defeq \lEW^?;\lJF \setminus \lCF$
    \end{itemize}
  \item $\lMO \subseteq \lW \times \lW$ --- \emph{modification order},
    which is a strict partial order.
  \end{itemize}
\end{definition}

\begin{definition}
  Using the primitive relations of an event structure $\lES$,
  we define following derived relations:
  \begin{itemize}
    \item $\lES.\lRB \defeq (\lES.\lRF^{-1};\lES.\lMO) \setminus \lES.\lCF^?$ --- 
      \emph{reads before};
    \item $\lES.\lECO \defeq (\lES.\lRF \cup \lES.\lRB \cup \lES.\lMO)^+$ --- 
      \emph{extended coherence order}.
  \end{itemize}
\end{definition}

\begin{definition}
  Giving an event structure $\lES$ we define the \emph{happens-before} relation $\lHB$
  using auxililarly relations: 
  $\lRSEQ$ --- release sequence,
  $\lRELP$ --- release prefix and
  $\lSW$ --- synchronize-with.
  \begin{itemize}
  \item $\lRSEQ \defeq [\lWsqeq{rlx}];(\lmakeLoc{\lPO};[\lWsqeq{rlx}] \cup 
    (\lmakeLoc{\lPO^?};[\lWsqeq{\rlx}];\lJF;\lRMW)^*)$;
  \item $\lRELP \defeq [\lEsqeq{rel}];([\lW] \cup [\lF];\lPO);\lRSEQ$;
  \item $\lSW \defeq \lRELP; (\lRFI \cup \lmakeLoc{\lPO^?};\lRFE); [\lR \cup \lPO;[\lF]);[\lEsqeq{\acq}]$;
  \item $\lHB \defeq (\lPO \cup \lSW)^+$.
  \end{itemize}
\end{definition}


\begin{definition}
  For an event structure $S$ the set of its visible events $\lVIS(S)$ defined as follow:
  \begin{itemize}
    \item $\lVIS(S) \defeq 
      \{ e \in S ~|~ S.\lW;(S.\lCF \cap (S.\lPO \cup S.\lJF)^+);[e] \subseteq 
         S.\lEW;S.\lPO^=
      \}$,
  \end{itemize}
\end{definition}

\begin{definition}
  Event structure $S$ is called \emph{consistent} if the following conditions hold:
  
  \begin{itemize}

    \item $S.\lJF \subseteq S.\lPO \cup (\lVIS(S) \times S.\lE)$;

    \item $S.\lJF \cap S.\lCF = \emptyset$;

    \item $(S.\lHB;S.\lJF^{-1}) \cap S.\lCF = \emptyset$;

    \item $S.\lHB;S.\lECO^?$ is irreflexive.
  \end{itemize}
\end{definition}

\begin{definition}
  Given an event structure $S$ we will a call an execution graph $X$
  extracted from $S$, denoted as $S \rhd X$,
  if there exists a function $f : X.\lE \fun S.\lE$, called \emph{source event mapping},
  such that the following conditions are met.
  \begin{itemize}
    \item $\lf(X.\lE) \subseteq \lVIS(S)$;
    \item $[\lf(X.\lE)];S.\lCF;[\lf(X.\lE)] = \emptyset$;
    \item $S.\lPO;[\lf(X.\lE)] \subseteq \lf(X.\lE) \times \lf(X.\lE)$;
    \item $[\lf(X.\lE)];S.\lPO;[S.\lE \setminus \lf(X.\lE)] \subseteq
           [\lf(X.\lE)];S.\lPO;[\lf(X.\lE)];S.\lCF$;
    \item $\lf(X.\lPO)  = [\lf(X.\lE)];S.\lPO; [\lf(X.\lE)]$;
    \item $\lf(X.\lRMW) = [\lf(X.\lE)];S.\lRMW;[\lf(X.\lE)]$;
    \item $\lf(X.\lRF)  = [\lf(X.\lE)];S.\lRF; [\lf(X.\lE)]$;
    \item $\lf(X.\lMO)  = [\lf(X.\lE)];S.\lMO; [\lf(X.\lE)]$;
  \end{itemize}
\end{definition}

\section{Compilation correctness}

\begin{theorem}
  For every consistent \imm execution graph $G$
  there exists a consistent event structure $S$
  s.t. $S \rhd G.X$.
\end{theorem}

\subsection{Traversal}

\begin{definition}
  An event $e \in G.\lE$ is \emph{coverable} in \imm execution graph $G$ and $\tup{C, I}$,
  denoted $e \in \coverable(G, C, I)$, 
  if $\dom{G.\lPO;[e]} \subseteq C$ and either:
  \begin{itemize}
    \item $e \in G.\lW \cap I$;
    \item $e \in G.\lR \wedge \dom{G.\lRF;[e]} \subseteq I$;
    \item $e \in G.\lF^{\sqsubset\sco}$;
    \item $e \in G.\lF^{\sco} \wedge \dom{G.\lSC;[e]} \subseteq C$.
  \end{itemize}
\end{definition}

\begin{definition}
  A write event $w \in G.\lW$ is \emph{issuable} in \imm execution graph $G$ and $\tup{C, I}$,
  denoted $w \in \issuable(G, C, I)$, 
  if the following conditions are met:
  \begin{itemize}
    \item $\dom{([G.\lW^{rel}];\lmakeLoc{G.\lPO} \cup [G.\lF];G.\lPO);[w]} \subseteq C$
    \item $\dom{(G.\lDETOUR \cup G.\lRFE);G.\lPPO;[w]} \subseteq I$
    \item $\dom{(G.\lDETOUR \cup G.\lRFE);[G.R^{acq}];G.\lPO;[w]} \subseteq I$
  \end{itemize}
\end{definition}

\begin{definition}
  A traversal configuration of an \imm execution graph $G$ is a pair $\tup{C, I}$, 
  where $C \subseteq G.\lE$ is a set of \emph{covered} events 
  and $I \subseteq G.\lW$ is a set of \emph{issued} events,
  that additionally satisfies the following properties:
  \begin{itemize}
    \item $G.\lEo \subseteq C$;
    \item $C \cap G.\lW \subseteq I$;
    \item $C \subseteq \coverable(G, C, I)$;
    \item $I \subseteq \issuable(G, C, I)$;
  \end{itemize}
  Configuration is called \emph{initial} when $C = I = G.\lEo$.
\end{definition}

\begin{definition}
  For an \imm execution graph $G$ and a traversal configuration $\tup{C, I}$
  a set of \emph{next events} is a set defined as follows:
  \begin{itemize}
    \item $\nextset(G, C, I) \defeq \{e \in G.\lE ~|~ \dom{G.\lPO;[e]} \subseteq C \} \setminus C$
  \end{itemize}
\end{definition}

\begin{definition}
  A traversal step relation $G \vdash \tup{C, I} \trstep \tup{C', I'}$
  is defined according to rules on figure~\ref{fig:traversal-step}.
\end{definition}

\begin{figure}[thb]

\small
    
    \begin{center}
    \AxiomC{$e \in \nextset(G, C) \cap \coverable(G, C, I)$}
    \UnaryInfC{$
      G \vdash \tup{C, I} \rightarrow \tup{C \uplus \{e\}, I}
    $}
    \DisplayProof
    % 
    \rulehskip
    % 
    \AxiomC{$w \in \issuable(G, C, I) \setminus I$}
    \UnaryInfC{$
      G \vdash \tup{C, I} \rightarrow \tup{C, I \uplus \{w\}}
    $}
    \DisplayProof
    \end{center}
    
    \caption{Traversal step relation}
    \label{fig:traversal-step}
\end{figure}

\subsection{Simulation relation}

\subsubsection{Basic simulation}

\begin{definition}
  An pair of events $\tup{e, \hat{e}}$ where $e \in G.\lE$ and $\hat{e} \in S.\lE$
  is a \emph{forwarding pair} in
  the traversal configuration $\tup{C, I}$ of the \imm execution graph $G$,
  denoted as $\tup{e, \hat{e}} \in \forward(S, G, \tup{C, I}, f)$, if the following is true:
  \begin{enumerate}[label=\textbf{F.\arabic*}]

    \item \label{item:frwd-coverable}
      $G \vdash \tup{C, I} \trstep \tup{C \uplus \{e\}, I}$;
     
    \item \label{item:frwd-lab}
      $G.\lLAB(e) = S.\lLAB(\hat{e})$;

    \item \label{item:frwd-front}
      $S.\lPO;[\hat{e}] \subseteq [\lf(C)];S.\lPO$

    \item \label{item:frwd-rf}
      $\forall{w \in G.\lW} ~.~ \tup{w, e} \in G.\lRF \Rightarrow \tup{\lf(w), \hat{e}} \in S.\lRF$.

  \end{enumerate}
\end{definition}

\begin{definition}
  Relation $\simRb(S, G, \tup{C, I}, f)$, that binds an 
  event structure $S$, an \imm execution graph $G$,
  a traversal configuration $\tup{C, I}$
  and an event mapping $f : G.\lE \fun S.\lE$ 
  holds if the following conditions are met:
  \begin{enumerate}[label=\textbf{S.\arabic*}]

    \item \label{item:sim-inj}
      $\forall{e_1, e_2 \in C \cup I} ~.~ \lf(e_1) = \lf(e_2) \Rightarrow e_1 = e_2$;

    \item \label{item:sim-lab}
      $\forall{e \in C \cup I} ~.~ G.\lLAB(e) = S.\lLAB(\lf(e))$;

    \item \label{item:sim-po-prfx} 
      $S.\lPO;[\lf(C)] \subseteq [\lf(C)];S.\lPO$;

    \item \label{item:sim-po}
      $\lf([C];G.\lPO;[C]) = [\lf(C)];S.\lPO;[\lf(C)]$;
    
    \item \label{item:sim-cf}
      $[\lf(C)];S.\lCF;[\lf(C)] = \emptyset$;

    \item \label{item:sim-rf}
      $\lf([I];G.\lRF;[C]) = [\lf(I)];S.\lRF;[\lf(C)]$;

    \item \label{item:sim-mo}
      $\lf([I];G.\lMO;[I]) = [\lf(I)];S.\lMO;[\lf(I)]$.
    
  \end{enumerate}
\end{definition}

\begin{lemma}
  \label{lemma:sim-forward}
  Given $S$, $G$, $\tup{C, I}$, $\lf$
  if the relation $\simRb(S, G, \tup{C, I}, f)$ holds and 
  there exists forwarding pair $\tup{e, \hat{e}} \in \forward(S, G, \tup{C, I}, f)$
  then $\simRb(S, G, \tup{C \uplus \{e\}, I}, f)$ holds. 
\end{lemma}

\begin{proof}
  % Let us prove that all conditions for $\simRb(S, G, \tup{C \uplus \{e\}, I}, f)$ are met.

  % \begin{itemize}

  % \item \ref{item:sim-lab} \\
  %   \begin{equation}
  %     \begin{split}
  %       & \forall{a \in (C \uplus \{e\}) \cup I} ~.~ G.\lLAB(a) = S.\lLAB(s(a)) \iff \\
  %       & \forall{a \in C \cup I} ~.~
  %         G.\lLAB(a) = S.\lLAB(s(a)) \wedge G.\lLAB(e) = S.\lLAB(s(e))
  %     \end{split}
  %   \end{equation}
  %   First conjunct follows from the $\simRb(S, G, \tup{C, I}, s, t)$.
  %   Second conjunct follows from the \ref{item:frwd-descr}.

  % \item \ref{item:sim-cf} \\
  %   We need to show that
  %   $\forall{a, b \in C \uplus \{e\}} ~.~ \tup{s(a), s(b)} \not\in S.\lCF$.
  %   Let us consider the opposite, that is
  %   $\exists{a, b \in C \uplus \{e\}} ~.~ \tup{s(a), s(b)} \in S.\lCF$.
  %   Giving that $\simRb(S, G, \tup{C, I}, s, t)$ holds,
  %   we can conclude that \mbox{$a = e \vee b = e$}.
  %   Let us suppose that $a = e$.
  %   Consider $c$ such that $\tup{c, e} \in G.\lPO_{imm}$.
  %   Because $e \in \coverable(G, C, I)$ we know that $c \in C$.
  %   From that and $\simRb(S, G, \tup{C, I}, s, t)$
  %   we can conclude that $\tup{s(b), s(c)} \not\in S.\lCF$.
  %   If $\tup{s(b), s(c)} \in S.\lPO$ then by transitivity of $S.\lPO$
  %   $\tup{s(b), s(e)} \in S.\lPO$
  %   which contradicts the fact that $\tup{s(b), s(e)} \in S.\lCF$.
  %   Otherwise \mbox{$\tup{s(c), s(b)} \in S.\lPO$}.
  %   From \ref{item:sim-po-imm} follows that $\tup{c, b} \in G.\lPO$
  %   and thus $\tup{e, b} \in G.\lPO$.
  %   But since $b \in C$ and thus $b \in \coverable(G, C, I)$,
  %   we can conclude that it shoud be the case that $e \in C$.
  %   But that contradicts $e \in \nextset(G, C, I)$.

  % \item \ref{item:sim-po-prfx} \\

  %   \begin{equation*}
  %     \begin{split}
  %       &     S.\lPO;[s(C \uplus \{e\})] \subseteq [s(C \uplus \{e\})];S.\lPO \iff \\
  %       &\iff S.\lPO;[s(C)] \cup S.\lPO;[s(e)] \subseteq [s(C)];S.\lPO \cup [s(e)];S.\lPO
  %     \end{split}
  %   \end{equation*}

  %   $S.\lPO;[s(C)] \subseteq [s(C)];S.\lPO$ because $\simRb(S, G, \tup{C, I}, s, t)$ holds.
  %   Let us show that $S.\lPO;[s(e)] \subseteq [s(C)];S.\lPO$.
  %   Suppose there exists $\hat{a}$ s.t. $\tup{\hat{a}, s(e)} \in S.\lPO$ but
  %   $\hat{a} \not\in s(C)$.
  %   Because of \ref{item:frwd-front}
  %   it must be the case that $\tup{\hat{a}, s(\front(C, \lTID(e))} \in S.\lPO$.
  %   But $\front(C, \lTID(e)) \in C$ and thus from $\ref{item:sim-po-prfx}$
  %   of $\simRb(S, G, \tup{C, I}, s, t)$ follows that $\hat{a} \in s(C)$. Contradiction.

  % \item \ref{item:sim-po} \\
  %   First, note that 
    
  %   \begin{equation*}
  %     \begin{split}
  %       [C \uplus \{e\}];G.\lPO;[C \uplus \{e\}] =
  %         [C];G.\lPO;[C] \cup [C];G.\lPO;[e] \cup [e];G.\lPO;[C]
  %     \end{split}
  %   \end{equation*}

  %   Also, as $e \in \nextset(G, C, I)$, $e \not\in C$ and
  %   because $C$ is $G.\lPO$ prefix closed, $[e];G.\lPO;[C]$ is empty.
  %   Thus we only have to show that

  %   \begin{equation*}
  %     \begin{split}
  %       & \forall{\tup{e_1, e_2} \in [C];G.\lPO;[C] \cup [C];G.\lPO;[e]} ~.~
  %           \tup{s(e_1), s(e_2)} \in S.\lPO \iff \\
  %       & \iff
  %         \forall{\tup{e_1, e_2} \in [C];G.\lPO;[C]} ~.~ \tup{s(e_1), s(e_2)} \in S.\lPO ~ \wedge \\
  %       & \wedge
  %         \forall{\tup{e_1, e_2} \in [C];G.\lPO;[e]} ~.~ \tup{s(e_1), s(e_2)} \in S.\lPO
  %     \end{split}
  %   \end{equation*}

  %   First conjunct follows from the $\simRb(S, G, \tup{C, I}, s, t)$.
  %   Let $c = \front(C, \lTID(\hat{e}))$. 
  %   From \ref{item:frwd-front} we know that $\tup{s(c), s(e)} \in S.\lPO_{imm}$.
  %   Thus, from \ref{item:sim-po-imm} of $\simRb(S, G, \tup{C, I}, s, t)$
  %   follows that $\tup{c, e} \in G.\lPO_{imm}$ and $c \in C$.
  %   From that and \ref{item:sim-po} of $\simRb(S, G, \tup{C, I}, s, t)$
  %   we can conclude that \\
  %   $\forall{\tup{e_1, e_2} \in [C];G.\lPO;[c]} ~.~ \tup{s(e_1), s(e_2)} \in S.\lPO$.
  %   The second conjunct follows directly from the later fact and the transitivity of $\lPO$.

  % \item \ref{item:sim-rf} \\
    
  %   \begin{equation*}
  %     \begin{split}
  %       & \forall{\tup{w, r} \in [I];G.\lRF;[C \uplus \{e\}]} ~.~
  %         \tup{s'(w), s'(r)} \in S.\lRF \iff \\
  %       & \iff \forall{\tup{w, r} \in [I];G.\lRF;[C]} ~.~ \tup{s(w), s(r)} \in S.\lRF ~ \wedge \\
  %       & \wedge \forall{w \in I}. \tup{w, e} \in G.\lRF \Rightarrow \tup{s(w), \hat{e}} \in S.\lRF
  %     \end{split}
  %   \end{equation*}

  %   Left conjunct follows immediately from $\simRb(S, G, \tup{C, I}, s, t)$.
  %   Right conjunct follows from the \ref{item:frwd-rf}.
    
  % \end{itemize}
  
\end{proof}

\begin{lemma}
  Given $S$, $G$, $\tup{C, I}$, $\lf$, $\Prog$ and $\Execs{\Prog}$
  s.t. $\Execs{\Prog} \vdash G$,
  if the relation $\simRb(S, G, \tup{C, I}, f)$ holds and
  there exists $e$ s.t. $G \vdash \tup{C, I} \trstep \tup{C \uplus \{e\}, I}$ then
  there exists $\hat{e}, S', f'$ such that
  $\Execs{\Prog} \vdash S \esstep{\hat{e}} S'$
  and $\simRb(S', G, \tup{C \uplus \{e\}, I}, f')$ holds.
\end{lemma}

\begin{proof}
  %% If we can show that $\simRb(S', G, \tup{C, I}, s', t')$ holds and
  %% $e \in \forward(S', G, \tup{C, I}, s', t')$ then by Lemma \ref{lemma:sim-forward}
  %% it follows that $\simRb(S', G, \tup{C \uplus \{e\}, I}, s', t')$ holds.

  %% First, let us show that $\simRb(S', G, \tup{C, I}, s', t')$ holds.

  %% \begin{itemize}

  %% \item \ref{item:sim-dom-s} and \ref{item:sim-dom-t} holds trivially.

  %% \item \ref{item:sim-ts-id}-\ref{item:sim-lab-wf} follows trivially from [BASIC-STEP].

  %% \item \ref{item:sim-cf}-\ref{item:sim-po} holds, because
  %%   $e \in \nextset(G, C, I)$,
  %%   %(thus $e \not\in C$ and $\forall{a \in C}~.~\tup{a, e} \in G.\lPO$),
  %%   $s'_{|C} = s_{|C}$ and $\simRb(S, G, \tup{C, I}, s, t)$.

  %% \item \ref{item:sim-po-imm} holds, because we have added to $S$
  %%   one single $\lPO_{imm}$ edge, that is $\tup{s(c), \hat{e}}$.
  %%   We also know that $t(\hat{e}) = e$ and since $e \in \nextset(G, C, I)$
  %%   there is a corresponding $\lPO_{imm}$ edge in $G$ ($\tup{c, e} \in G.\lPO_{imm}$).

  %% \item \ref{item:sim-rf} \\
  %%   If $e \not\in G.\lW$ then it holds trivially
  %%   (since in this case $s'_{|C \cup I} = s_{|C \cup I}$).
  %%   Otherwise consider $s(e)$ and $s'(e)$.
  %%   From [WRITE-STEP] we know that $\tup{s(e), s'(e)} \in S.\lEW$.
  %%   This leads to 
  %%   $\forall{\tup{w, r} \in [e];G.\lRF;[C]} ~.~ \tup{s'(w), s'(r)} \in S.\lJF$,
  %%   and thus \ref{item:sim-rf} holds.

  %% \item \ref{item:sim-ew} \\
  %%   If $e \not\in G.\lW$ then it holds trivially.
  %%   Otherwise, from \ref{item:sim-ew} of $\simRb(S, G, \tup{C, I}, s, t)$ we know that
  %%   $\forall{\hat{w_1}, \hat{w_2} \in S.\lW} ~.~ t(\hat{w_1}) = t(\hat{w_2}) = e
  %%   \Rightarrow \tup{\hat{w_1}, \hat{w_2}} \in S.\lEW$.
  %%   Also, we know that $e \in I$ (because $e \in G.\lW \cap \coverable(G, C, I)$)
  %%   and thus $t(s(e)) = e$.
  %%   From [WRITE-STEP] $\tup{s(e), s'(e)} \in S.\lEW$ and thus
  %%   $\forall{\hat{w} \in S.\lW}~.~ t(\hat{w}) = e \Rightarrow \tup{\hat{w}, s'(e)} \in S.\lEW$.
  %%   That means \ref{item:sim-ew} holds.
  
  %% \end{itemize}

  %% Now, let us show that $e \in \forward(S', G, \tup{C, I}, s', t')$.

  %% \begin{itemize}

  %%   \item \ref{item:frwd-coverable} is a Lemma primise;

  %%   \item \ref{item:frwd-dom-s}, \ref{item:frwd-ts-id} and \ref{item:frwd-descr}
  %%     follows trivially from [BASIC-STEP];

  %%   \item \ref{item:frwd-front}
  %%     $\tup{s(\front(C, \lTID(\hat{e}))), s(e)} \in S.\lPO_{imm}$;

  %%   \item \ref{item:frwd-rf}
  %%     $\tup{\hat{w}, s(e)} \in S.\lRF \Leftrightarrow \tup{t(\hat{w}), e} \in G.\lRF$.
    
  %% \end{itemize}
\end{proof}

\subsubsection{Weak and strong simulation}

\begin{definition}
  Relation $\simRw(S, G, \tup{C, I}, \lf, \phi)$, that binds an 
  event structure $S$, an \imm execution graph $G$,
  a traversal configuration $\tup{C, I}$,
  an event mapping $f : G.\lE \fun S.\lE$,
  and an event $\phi \in C$,
  holds whenever $\simRb(S, G, \tup{C, I}, s)$ holds and
  additionally the following condition is met:
  \begin{enumerate}[label=\textbf{S$_{weak}$.\arabic*},start=8]
     
    \item \label{item:sim-vis-weak}
      $\lf(C \cup I \setminus \codom{[\phi];\lPO}) \subseteq \lVIS(S)$

  \end{enumerate}
\end{definition}

\begin{definition}
  Given $S$, $G$, $\tup{C, I}$, $\lf$ a relation $\simR(S, G, \tup{C, I}, f)$ holds
  whenever $\simRb(S, G, \tup{C, I}, f)$ holds and additionally
  the following condition is met:
  \begin{enumerate}[label=\textbf{S.\arabic*},start=8]
    \item \label{item:sim-vis}
       $\lf(C \cup I) \subseteq \lVIS(S)$
  \end{enumerate}
\end{definition}

\begin{definition}
  A traversal configuration $\tup{C, I}$ is called \emph{strict}
  if for every configuration $\tup{C', I'}$ reachable from it,
  that is $G \vdash \tup{C, I} \trstepstar \tup{C', I'}$,
  and every $w \in G.\lW$ s.t.
  $G \vdash \tup{C', I'} \trstep \tup{C', I' \cup \{w\}}$
  $w$ might be covered in a next step, that is
  $w \in \coverable(G, C', I' \cup \{w\})$.
\end{definition}

\begin{lemma}
  Given $S$, $G$, $\tup{\lC, I}$, $\lf$, $\phi$, $\Prog$ and $\Execs{\Prog}$
  s.t. $\Execs{\Prog} \vdash G$, $\tup{C, I}$ is strict
  and $\simRw(S, G, \tup{C, I}, \lf, \phi)$ holds
  if $G \vdash \tup{C, I} \trstep \tup{C', I'}$ then
  there exists $S', f'$ such that
  $\Execs{\Prog} \vdash S \esstepstar S'$ s.t.
  $\simR(S', G, \tup{C', I'}, f')$ hold.
\end{lemma}

\begin{proof}

\end{proof}

\begin{lemma}
  Given $S$, $G$, $\tup{C, I}$, $\lf$, $\Prog$ and $\Execs{\Prog}$
  s.t. $\Execs{\Prog} \vdash G$,
  if the relation $\simR(S, G, \tup{C, I}, f)$ holds
  and $G \vdash \tup{C, I} \trstep \tup{C', I'}$
  then there exists $S'$ and $f'$ s.t.
  $\Execs{\Prog} \vdash S \esstepstar S'$ and
  $\simR(S, G, \tup{C, I}, f)$ holds.
\end{lemma}

\begin{proof}
  
\end{proof}

\subsubsection{Execution extraction}

\begin{lemma}
  Given $S$, $G$, $\tup{C, I}$, $\lf$, $\Prog$ and $\Execs{\Prog}$
  s.t. $\Execs{\Prog} \vdash G$ and $\simR(S, G, \tup{C, I}, f)$ hold
  then there exists $G^{\cert} \in \certify(\Execs{\Prog}, G, C, I)$ s.t.
  $S \rhd G^{\cert}$ holds.
\end{lemma}

\begin{proof}
  
\end{proof}
  
\setmonofont[Mapping=tex-text]{CMU Typewriter Text}
\bibliographystyle{acm}
\bibliography{main.bib}

\end{document}
